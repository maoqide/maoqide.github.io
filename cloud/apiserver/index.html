<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.51" />
    <meta name="description" content="for learning">
<meta name="author" content="maoqide">

    <link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon" />
<link rel="icon" href="/images/favicon.png" type="image/x-icon" />
    <title>Apiserver :: Maoqide</title>

    
    <link href="/css/nucleus.css?1544703889" rel="stylesheet">
    <link href="/css/fontawesome-all.min.css?1544703889" rel="stylesheet">
    <link href="/css/hybrid.css?1544703889" rel="stylesheet">
    <link href="/css/featherlight.min.css?1544703889" rel="stylesheet">
    <link href="/css/perfect-scrollbar.min.css?1544703889" rel="stylesheet">
    <link href="/css/auto-complete.css?1544703889" rel="stylesheet">
    <link href="/css/theme.css?1544703889" rel="stylesheet">
    <link href="/css/hugo-theme.css?1544703889" rel="stylesheet">
    
    
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?c3c6dd2eb79bc741d95463b6040ac868";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
    <script src="/js/jquery-2.x.min.js?1544703889"></script>

    <style type="text/css">
      :root #header + #content > #left > #rlblock_left{
          display:none !important;
      }
      
        :not(pre) > code + span.copy-to-clipboard {
            display: none;
        }
      
    </style>
    
  </head>
  <body class="" data-url="/cloud/apiserver/">
    <nav id="sidebar" class="showVisitedLinks">



  <div id="header-wrapper">
    <div id="header">
      <a id="logo" href="">
  <svg  width="100%" height="100%" viewBox="0 0 504 140" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <text x="30" y="110" fill="#F1F4F5" font-weight="bold" font-family="'Courier New', Courier, monospace" font-size="80">Maoqide</text>

    
  </svg>
</a>
    </div>
    
        <div class="searchbox">
    <label for="search-by"><i class="fas fa-search"></i></label>
    <input data-search-input id="search-by" type="text" placeholder="Search...">
    <span data-search-clear=""><i class="fas fa-close"></i></span>
</div>

<script type="text/javascript" src="/js/lunr.min.js?1544703889"></script>
<script type="text/javascript" src="/js/auto-complete.js?1544703889"></script>
<script type="text/javascript">
    
        var baseurl = "";
    
</script>
<script type="text/javascript" src="/js/search.js?1544703889"></script>

    
  </div>

    <div class="highlightable">
    <ul class="topics">

        
          
          


 
  
    
    <li data-nav-id="/collection/" title="Collection" class="dd-item 
        
        
        
        ">
      <a href="/collection/">
          Collection
          
            <i class="fas read-icon"></i>
          
      </a>
      
      
        <ul>
          
          
          
          
        
          
            
            


 
  
    
      <li data-nav-id="/collection/collection-1/" title="Collection 1" class="dd-item ">
        <a href="/collection/collection-1/">
        Collection 1
        <i class="fas fa-check read-icon"></i>
        </a>
    </li>
     
  
 

            
          
        
        </ul>
              
    </li>
  
 

          
          


 
  
    
    <li data-nav-id="/algorithm/" title="Algorithm" class="dd-item 
        
        
        
        ">
      <a href="/algorithm/">
          Algorithm
          
            <i class="fas read-icon"></i>
          
      </a>
      
              
    </li>
  
 

          
          


 
  
    
    <li data-nav-id="/cloud/" title="Cloud" class="dd-item 
        parent
        
        
        ">
      <a href="/cloud/">
          Cloud
          
            <i class="fas read-icon"></i>
          
      </a>
      
      
        <ul>
          
          
            
          
          
          
        
          
            
            


 
  
    
      <li data-nav-id="/cloud/apiserver/" title="Apiserver" class="dd-item active">
        <a href="/cloud/apiserver/">
        Apiserver
        <i class="fas fa-check read-icon"></i>
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
    <li data-nav-id="/cloud/kubelet/" title="Kubelet" class="dd-item 
        
        
        
        ">
      <a href="/cloud/kubelet/">
          Kubelet
          
            <i class="fas read-icon"></i>
          
      </a>
      
              
    </li>
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/cloud/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BA-k8s-%E9%9B%86%E7%BE%A4/" title="阿里云主机搭建 K8S 集群" class="dd-item ">
        <a href="/cloud/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BA-k8s-%E9%9B%86%E7%BE%A4/">
        阿里云主机搭建 K8S 集群
        <i class="fas fa-check read-icon"></i>
        </a>
    </li>
     
  
 

            
          
        
        </ul>
              
    </li>
  
 

          
          


 
  
    
    <li data-nav-id="/notes/" title="Notes" class="dd-item 
        
        
        
        ">
      <a href="/notes/">
          Notes
          
            <i class="fas read-icon"></i>
          
      </a>
      
      
        <ul>
          
          
          
          
        
          
            
            


 
  
    
      <li data-nav-id="/notes/build-blog-with-hugo/" title="Build Blog With Hugo" class="dd-item ">
        <a href="/notes/build-blog-with-hugo/">
        Build Blog With Hugo
        <i class="fas fa-check read-icon"></i>
        </a>
    </li>
     
  
 

            
          
        
        </ul>
              
    </li>
  
 

          
          


 
  
    
    <li data-nav-id="/contact/" title="Contact" class="dd-item 
        
        
        
        ">
      <a href="/contact/">
          Contact
          
            <i class="fas read-icon"></i>
          
      </a>
      
              
    </li>
  
 

          
         
    </ul>

    
    
      <section id="shortcuts">
        <h3></h3>
        <ul>
          
              <li> 
                  <a class="padding" href="https://github.com/maoqide"><i class='fab fa-github'></i> Github</a>
              </li>
          
        </ul>
      </section>
    

    
    <section id="prefooter">
      <hr/>
      <ul>
      
      
      
        <li><a class="padding" href="#" data-clear-history-toggle=""><i class="fas fa-history fa-fw"></i> Clear History</a></li>
      
      </ul>
    </section>
    
    <section id="footer">
      <p>Built with <a href="https://github.com/matcornic/hugo-theme-learn"><i class="fas fa-heart"></i></a> from <a href="http://getgrav.org">Grav</a> and <a href="http://gohugo.io/">Hugo</a></p>

    </section>
  </div>
</nav>





        <section id="body">
        <div id="overlay"></div>
        <div class="padding highlightable">
              
              <div>
                <div id="top-bar">
                
                
                <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                    <span id="sidebar-toggle-span">
                        <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                          <i class="fas fa-bars"></i>
                        </a>
                    </span>
                  
                  <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
                  
                  <span class="links">
                 
                 
                   Apiserver 
                 
                  </span>
                </div>
                
                    <div class="progress">
    <div class="wrapper">
<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#代码结构">代码结构</a></li>
<li><a href="#app-run">app.Run</a></li>
<li><a href="#createserverchain">CreateServerChain</a></li>
<li><a href="#createkubeapiserverconfig">CreateKubeAPIServerConfig</a>
<ul>
<li><a href="#主要流程">主要流程</a></li>
<li><a href="#serviceresolver">ServiceResolver</a></li>
<li><a href="#sharedinformer">SharedInformer</a></li>
</ul></li>
<li><a href="#createkubeapiserver">CreateKubeAPIServer</a>
<ul>
<li><a href="#主要流程-1">主要流程</a></li>
<li><a href="#c-genericconfig-new">c.GenericConfig.New</a>
<ul>
<li><a href="#director">director</a></li>
<li><a href="#listedpathprovider">ListedPathProvider</a></li>
<li><a href="#installapi">installAPI</a></li>
</ul></li>
<li><a href="#m-installlegacyapi">m.InstallLegacyAPI</a>
<ul>
<li><a href="#newlegacyreststorage">NewLegacyRESTStorage</a></li>
<li><a href="#installlegacyapigroup">InstallLegacyAPIGroup</a></li>
</ul></li>
<li><a href="#m-installapis">m.InstallAPIs</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>

                
              </div>
            </div>
            

        
        <div id="body-inner">
          
            <h1>Apiserver</h1>
          

        


<p>k8s apiserver 源码阅读笔记</p>

<h2 id="代码结构">代码结构</h2>

<pre><code>本部分用于记录 apiserver 代码整体结构及关键方法，便于到源码中查找，个人阅读记录，读者可跳过。本文所有代码均基于 kubernetes 1.9.6。
</code></pre>

<pre><code class="language-golang">app.Run()
	CreateServerChain()
		CreateNodeDialer()	//ssh 连接
		CreateKubeAPIServerConfig()	//
			defaultOptions()
				DefaultAdvertiseAddress()
				DefaultServiceIPRange()
				MaybeDefaultWithSelfSignedCerts()
				ApplyAuthorization()
				IsValidServiceAccountKeyFile()
			Validate() //validate options
			BuildGenericConfig()	//takes the master server options and produces the genericapiserver.Config associated with it
				genericConfig
				genericConfig.OpenAPIConfig //config swagger
				BuildStorageFactory()		//constructs the storage factory

					func NewStorageFactory(storageConfig storagebackend.Config, defaultMediaType string, serializer runtime.StorageSerializer,
						defaultResourceEncoding *serverstorage.DefaultResourceEncodingConfig, storageEncodingOverrides map[string]schema.GroupVersion, resourceEncodingOverrides []schema.GroupVersionResource,
						defaultAPIResourceConfig *serverstorage.ResourceConfig, resourceConfigOverrides utilflag.ConfigurationMap) (*serverstorage.DefaultStorageFactory, error)

						// storageConfig -&gt; ETCD配置
						// defaultAPIResourceConfig -&gt;
						func DefaultAPIResourceConfigSource() *serverstorage.ResourceConfig
							type ResourceConfig struct {
								GroupVersionResourceConfigs map[schema.GroupVersion]*GroupVersionResourceConfig
							}
							func (o *ResourceConfig) EnableVersions(versions ...schema.GroupVersion)		//Enable GroupVersion
							func (o *ResourceConfig) EnableResources(resources ...schema.GroupVersionResource)    //daemonsets,deployments,ingresses,networkpolicies,replicasets,podsecuritypolicies

							// Specifies the overrides for various API group versions.
							// This can be used to enable/disable entire group versions or specific resources.
							type GroupVersionResourceConfig struct {
								// Whether to enable or disable this entire group version.  This dominates any enablement check.
								// Enable=true means the group version is enabled, and EnabledResources/DisabledResources are considered.
								// Enable=false means the group version is disabled, and EnabledResources/DisabledResources are not considered.
								Enable bool

								// DisabledResources lists the resources that are specifically disabled for a group/version
								// DisabledResources trumps EnabledResources
								DisabledResources sets.String

								// EnabledResources lists the resources that should be enabled by default.  This is a little
								// unusual, but we need it for compatibility with old code for now.  An empty set means
								// enable all, a non-empty set means that all other resources are disabled.
								EnabledResources sets.String
							}
					EtcdServersOverrides //override etcd配置
				client, err := internalclientset.NewForConfig(genericConfig.LoopbackClientConfig) // new a loopback client
				sharedInformers := informers.NewSharedInformerFactory(client, 10*time.Minute)	
					// SharedInformerFactory provides shared informers for resources in all known API group versions.
					type SharedInformerFactory interface {
						internalinterfaces.SharedInformerFactory
						ForResource(resource schema.GroupVersionResource) (GenericInformer, error)
						WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool

						Admissionregistration() admissionregistration.Interface
						Apps() apps.Interface
						Autoscaling() autoscaling.Interface
						Batch() batch.Interface
						Certificates() certificates.Interface
						Core() core.Interface
						Extensions() extensions.Interface
						Networking() networking.Interface
						Policy() policy.Interface
						Rbac() rbac.Interface
						Scheduling() scheduling.Interface
						Settings() settings.Interface
						Storage() storage.Interface
					}
				serviceResolver
					// A ServiceResolver knows how to get a URL given a service.
					type ServiceResolver interface {
						ResolveEndpoint(namespace, name string) (*url.URL, error)
					}

			DefaultServiceIPRange()
			BuildStorageFactory()
			readCAorNil()	//auth CA

			config := &amp;master.Config{}
				type Config struct {
					GenericConfig *genericapiserver.Config
					ExtraConfig   ExtraConfig
				}
		createAPIExtensionsConfig()
		createAPIExtensionsServer() // apiextensions-apiserver\pkg\apiserver\apiserver.go New() is the function for CustomResourceDefinitions to register router handler on GenericAPIServer
		CreateKubeAPIServer() // creates and wires a workable kube-apiserver,
			// returns a new instance of Master from the given config
			func (c completedConfig) New(delegationTarget genericapiserver.DelegationTarget) (*Master, error){} // goproject\src\k8s.io\kubernetes\pkg\master\master.go
				c.GenericConfig.New(&quot;kube-apiserver&quot;, delegationTarget)	// creates a new server which logically combines the handling chain with the passed server   !! important
					apiServerHandler := NewAPIServerHandler(name, c.RequestContextMapper, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())
						// k8s.io\apiserver\pkg\server\handler.go construct gorestfulContainer and add default handler(NotFoundHandler, RecoverHandler, ServiceErrorHandler)
						func NewAPIServerHandler(name string, contextMapper request.RequestContextMapper, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler) *APIServerHandler {}
							director := director{...}
								type director struct {
									name               string
									goRestfulContainer *restful.Container
									nonGoRestfulMux    *mux.PathRecorderMux
								}
								func (d director) ServeHTTP(w http.ResponseWriter, req *http.Request) {}
					s := &amp;GenericAPIServer{}	// k8s.io\apiserver\pkg\server\genericapiserver.go type GenericAPIServer
					add PostStartHooks &amp; PreShutdownHooks
					AddPostStartHook(PostStartHookFunc)	//	{c.SharedInformerFactory.Start(context.StopCh)}
					add healthzChecks
					installAPI(s, c.Config)		// install utils routes like SwaggerUI, Profiling, Metrics
				if () routes.DefaultMetrics{}.Install(s.Handler.NonGoRestfulMux)
				if () routes.Logs{}.Install(s.Handler.GoRestfulContainer)
				m := &amp;Master{ GenericAPIServer: s, }
				m.InstallLegacyAPI(&amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider)	// k8s.io\kubernetes\pkg\master\master.go, install core api routes, !!!!important 
					NewLegacyRESTStorage() -&gt; //定义如下 返回 LegacyRESTStorage和APIGroupInfo, Storage保存了具体资源对象的结构，如 PodStrorage
						// LegacyRESTStorage returns stateful information about particular instances of REST storage to master.go for wiring controllers
						func (c LegacyRESTStorageProvider) NewLegacyRESTStorage(restOptionsGetter generic.RESTOptionsGetter) (LegacyRESTStorage, genericapiserver.APIGroupInfo, error) {} // k8s.io\kubernetes\pkg\registry\core\rest\storage_core.go
							// Info about an API group.
							type APIGroupInfo struct {
								GroupMeta apimachinery.GroupMeta
								// Info about the resources in this group. Its a map from version to resource to the storage.
								VersionedResourcesStorageMap map[string]map[string]rest.Storage	// !!! important!!!!
								// OptionsExternalVersion controls the APIVersion used for common objects in the
								// schema like api.Status, api.DeleteOptions, and metav1.ListOptions. Other implementors may
								// define a version &quot;v1beta1&quot; but want to use the Kubernetes &quot;v1&quot; internal objects.
								// If nil, defaults to groupMeta.GroupVersion.
								// TODO: Remove this when https://github.com/kubernetes/kubernetes/issues/19018 is fixed.
								OptionsExternalVersion *schema.GroupVersion
								// MetaGroupVersion defaults to &quot;meta.k8s.io/v1&quot; and is the scheme group version used to decode
								// common API implementations like ListOptions. Future changes will allow this to vary by group
								// version (for when the inevitable meta/v2 group emerges).
								MetaGroupVersion *schema.GroupVersion

								// Scheme includes all of the types used by this group and how to convert between them (or
								// to convert objects from outside of this group that are accepted in this API).
								// TODO: replace with interfaces
								Scheme *runtime.Scheme
								// NegotiatedSerializer controls how this group encodes and decodes data
								NegotiatedSerializer runtime.NegotiatedSerializer
								// ParameterCodec performs conversions for query parameters passed to API calls
								ParameterCodec runtime.ParameterCodec
							}
							restStorage := LegacyRESTStorage{}
							// NewREST for basic resources
							podTemplateStorage := podtemplatestore.NewREST(restOptionsGetter)
							eventStorage := eventstore.NewREST(restOptionsGetter, uint64(c.EventTTL.Seconds()))
							limitRangeStorage := limitrangestore.NewREST(restOptionsGetter)
							resourceQuotaStorage, resourceQuotaStatusStorage := resourcequotastore.NewREST(restOptionsGetter)
							secretStorage := secretstore.NewREST(restOptionsGetter)
							serviceAccountStorage := serviceaccountstore.NewREST(restOptionsGetter)
							persistentVolumeStorage, persistentVolumeStatusStorage := pvstore.NewREST(restOptionsGetter)
							persistentVolumeClaimStorage, persistentVolumeClaimStatusStorage := pvcstore.NewREST(restOptionsGetter)
							configMapStorage := configmapstore.NewREST(restOptionsGetter)
							namespaceStorage, namespaceStatusStorage, namespaceFinalizeStorage := namespacestore.NewREST(restOptionsGetter)
		
							endpointsStorage := endpointsstore.NewREST(restOptionsGetter)
							endpointRegistry := endpoint.NewRegistry(endpointsStorage)
							podStorage := podstore.NewStorage()
							serviceRESTStorage, serviceStatusStorage := servicestore.NewREST(restOptionsGetter)
							serviceRegistry := service.NewRegistry(serviceRESTStorage)

							restStorageMap := map[string]rest.Storage{
								&quot;pods&quot;:             podStorage.Pod,
								&quot;pods/attach&quot;:      podStorage.Attach,
								// ...............
								&quot;configMaps&quot;:                    configMapStorage,
								&quot;componentStatuses&quot;: componentstatus.NewStorage(componentStatusStorage{c.StorageFactory}.serversToValidate),
							}
							apiGroupInfo.VersionedResourcesStorageMap[&quot;v1&quot;] = restStorageMap // set APIGroupInfo.VersionedResourcesStorageMap to return, !!!!!
					
					// construct BootstrapController and add hook
					NewBootstrapController()	// a controller for watching the core capabilities of the master
					AddPostStartHookOrDie() 	// { controller.start() }
					AddPreShutdownHookOrDie()   // { controller.stop() }

					InstallLegacyAPIGroup()
						func (s *GenericAPIServer) InstallLegacyAPIGroup(apiPrefix string, apiGroupInfo *APIGroupInfo) error {}
							if legacyAPIGroupPrefixes.Has(apiPrefix)
							installAPIResources()	// a private method for installing the REST storage backing each api groupversionresource
								for apiGroupInfo.GroupMeta.GroupVersions {
									// get rest.Storage from apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version]
									apiGroupVersion := s.getAPIGroupVersion(apiGroupInfo, groupVersion, apiPrefix)
									// InstallREST registers the REST handlers (storage, watch, proxy and redirect) into a restful Container
									apiGroupVersion.InstallREST(s.Handler.GoRestfulContainer)
										installer := &amp;APIInstaller{ group: g,...}
										installer.Install()
											// Install handlers for API resources. k8s.io\apiserver\pkg\endpoints\installer.go
											func (a *APIInstaller) Install() ([]metav1.APIResource, *restful.WebService, []error) {}
												paths := make([]string, len(a.group.Storage))
												for paths(storages) {
													apiResource, err := a.registerResourceHandlers(path, a.group.Storage[path], ws, proxyHandler)	
														// !!important(700+ lines...), function to actually add route to go-restful. k8s.io\apiserver\pkg\endpoints\installer.go
														// kubernetes把所有对资源对象的操作接口封装到一个action对象中，在 registerResourceHandlers 方法中，
														// 根据如 storage.(rest.Getter)的方法，获取 what verbs are supported by the storage, used to know what verbs we support per path，
														// 根据scope: RESTScopeNameRoot(Handle non-namespace scoped resources like nodes) 或 RESTScopeNameNamespace(Handler for standard REST verbs (GET, PUT, POST and DELETE))
														// 将 action append 到一个 actions 切片中(不同 scope ，path前缀不同)
														// 最后遍历actions，根据不同的action.Verb，注册到go-restful的 restful.WebService中，并将此对象支持的Verbs将入到apiResource.Verbs中并返回apiResource对象。
														func (a *APIInstaller) registerResourceHandlers(path string, storage rest.Storage, ws *restful.WebService, proxyHandler http.Handler) (*metav1.APIResource, error) {}
															// Struct capturing information about an action (&quot;GET&quot;, &quot;POST&quot;, &quot;WATCH&quot;, &quot;PROXY&quot;, etc).
															type action struct {
																Verb          string               // Verb identifying the action (&quot;GET&quot;, &quot;POST&quot;, &quot;WATCH&quot;, &quot;PROXY&quot;, etc).
																Path          string               // The path of the action
																Params        []*restful.Parameter // List of parameters associated with the action.
																Namer         handlers.ScopeNamer
																AllNamespaces bool // true iff the action is namespaced but works on aggregate result for all namespaces
															}
															// APIResource specifies the name of a resource and whether it is namespaced.
															type APIResource struct {
																// name is the plural name of the resource.
																Name string `json:&quot;name&quot; protobuf:&quot;bytes,1,opt,name=name&quot;`
																// singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
																// The singularName is more correct for reporting status on a single item and both singular and plural are allowed
																// from the kubectl CLI interface.
																SingularName string `json:&quot;singularName&quot; protobuf:&quot;bytes,6,opt,name=singularName&quot;`
																// namespaced indicates if a resource is namespaced or not.
																Namespaced bool `json:&quot;namespaced&quot; protobuf:&quot;varint,2,opt,name=namespaced&quot;`
																// group is the preferred group of the resource.  Empty implies the group of the containing resource list.
																// For subresources, this may have a different value, for example: Scale&quot;.
																Group string `json:&quot;group,omitempty&quot; protobuf:&quot;bytes,8,opt,name=group&quot;`
																// version is the preferred version of the resource.  Empty implies the version of the containing resource list
																// For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)&quot;.
																Version string `json:&quot;version,omitempty&quot; protobuf:&quot;bytes,9,opt,name=version&quot;`
																// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
																Kind string `json:&quot;kind&quot; protobuf:&quot;bytes,3,opt,name=kind&quot;`
																// verbs is a list of supported kube verbs (this includes get, list, watch, create,
																// update, patch, delete, deletecollection, and proxy)
																Verbs Verbs `json:&quot;verbs&quot; protobuf:&quot;bytes,4,opt,name=verbs&quot;`
																// shortNames is a list of suggested short names of the resource.
																ShortNames []string `json:&quot;shortNames,omitempty&quot; protobuf:&quot;bytes,5,rep,name=shortNames&quot;`
																// categories is a list of the grouped resources this resource belongs to (e.g. 'all')
																Categories []string `json:&quot;categories,omitempty&quot; protobuf:&quot;bytes,7,rep,name=categories&quot;`
															}
													apiResources = append(apiResources, *apiResource)
												}
								}
				m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...)	// InstallAPIs will install the APIs for the restStorageProviders if they are enabled.
					for restStorageProviders {
						apiGroupsInfo = append(apiGroupsInfo, apiGroupInfo)
					}
					for i := range apiGroupsInfo {
						m.GenericAPIServer.InstallAPIGroup(&amp;apiGroupsInfo[i])
							// installAPIResources is a private method for installing the REST storage backing each api groupversionresource, k8s.io\apiserver\pkg\server\genericapiserver.go
							func (s *GenericAPIServer) installAPIResources(apiPrefix string, apiGroupInfo *APIGroupInfo) error {}
								// ！！InstallREST registers the REST handlers (storage, watch, proxy and redirect) into a restful Container, k8s.io\apiserver\pkg\endpoints\groupversion.go
								apiGroupVersion.InstallREST(s.Handler.GoRestfulContainer
					}
				m.installTunneler(c.ExtraConfig.Tunneler, corev1client.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig).Nodes())
				m.GenericAPIServer.AddPostStartHookOrDie(&quot;ca-registration&quot;, c.ExtraConfig.ClientCARegistrationHook.PostStartHook)
			AddPostStartHook()		// addfunc {sharedInformers.Start(context.StopCh)}
		// openapi swagger
		// this wires up openapi
		kubeAPIServer.GenericAPIServer.PrepareRun()
		// This will wire up openapi for extension api server
		apiExtensionsServer.GenericAPIServer.PrepareRun()
		aggregatorConfig, err := createAggregatorConfig(*kubeAPIServerConfig.GenericConfig, runOptions, versionedInformers, serviceResolver, proxyTransport)
		aggregatorServer, err := createAggregatorServer(aggregatorConfig, kubeAPIServer.GenericAPIServer, apiExtensionsServer.Informers)
			aggregatorServer, err := aggregatorConfig.Complete().NewWithDelegate(delegateAPIServer)
				genericServer, err := c.GenericConfig.New(&quot;kube-aggregator&quot;, delegationTarget) // ----same function with called in CreateKubeAPIServer-&gt;New() (91)
				apiregistrationClient, err := internalclientset.NewForConfig(c.GenericConfig.LoopbackClientConfig)
					configShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)
					cs.apiregistration, err = apiregistrationinternalversion.NewForConfig(&amp;configShallowCopy)
					cs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfig(&amp;configShallowCopy)
					informerFactory := informers.NewSharedInformerFactory(apiregistrationClient,5*time.Minute,)
					s := &amp;APIAggregator{}	// APIAggregator contains state for a Kubernetes cluster master/api server.
					v1beta1storage := map[string]rest.Storage{}
					apiServiceREST := apiservicestorage.NewREST(Scheme, c.GenericConfig.RESTOptionsGetter)
					v1beta1storage[&quot;apiservices&quot;] = apiServiceREST
					v1beta1storage[&quot;apiservices/status&quot;] = apiservicestorage.NewStatusREST(Scheme, apiServiceREST)
					// rest implements a RESTStorage for API services against etcd
					type REST struct {
						*genericregistry.Store
					}
					apiGroupInfo.VersionedResourcesStorageMap[&quot;v1beta1&quot;] = v1beta1storage
					s.GenericAPIServer.InstallAPIGroup(&amp;apiGroupInfo)		// ----same function with called in CreateKubeAPIServer-&gt;New()-&gt;InstallAPIs() (237)
					s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(&quot;/apis&quot;, apisHandler)
					s.GenericAPIServer.Handler.NonGoRestfulMux.UnlistedHandle(&quot;/apis/&quot;, apisHandler)
					apiserviceRegistrationController := NewAPIServiceRegistrationController(informerFactory.Apiregistration().InternalVersion().APIServices(), c.GenericConfig.SharedInformerFactory.Core().V1().Services(), s) // add event handler to informer
					s.GenericAPIServer.AddPostStartHook(&quot;start-kube-aggregator-informers&quot;)
					s.GenericAPIServer.AddPostStartHook(&quot;apiservice-registration-controller&quot;)
					s.GenericAPIServer.AddPostStartHook(&quot;apiservice-status-available-controller&quot;)
					// BuildAndRegisterAggregator registered OpenAPI aggregator handler. 
					openAPIAggregator, err := openapicontroller.BuildAndRegisterAggregator()
			// create controllers for auto-registration
			apiRegistrationClient, err := apiregistrationclient.NewForConfig(aggregatorConfig.GenericConfig.LoopbackClientConfig)
			// ......
</code></pre>

<h2 id="app-run">app.Run</h2>

<p>kubernetes所有组件的入口，基本上都是在<code>$GOPATH\k8s.io\kubernetes\cmd\xxx(组件名称)</code>下面的main文件中。
apiserver对应的路径为<code>$GOPATH\k8s.io\kubernetes\cmd\kube-apiserver\apiserver.go</code>，main函数中通过<code>app.Run(s, stopCh)</code>方法，执行具体逻辑。
具体Run方法，定义在<code>$GOPATH\k8s.io\kubernetes\cmd\kube-apiserver\app\server.go</code>中。</p>

<p>apiserver的<code>app.Run()</code>，主要通过 <code>CreateServerChain()</code> 方法，创建出一个<code>*genericapiserver.GenericAPIServer</code>实例。<br />
在<code>GenericAPIServer</code>中，包含的主要结构体有<br />
- <code>*APIServerHandler</code>(<em>Handler holds the handlers being used by this API server</em>)
- <code>DelegationTarget</code>(<em>delegationTarget is the next delegate in the chain or nil</em>)<br />
其中最重要的是<code>APIServerHandler</code>这个结构体，它包含了go-restful中的<code>*restful.Container</code>结构体，后面注册API时用到的<code>InstallAPIs()</code>方法，最终也是将路由注册到这个Container中，定义如下:</p>

<pre><code class="language-golang">// APIServerHandlers holds the different http.Handlers used by the API server.
// This includes the full handler chain, the director (which chooses between gorestful and nonGoRestful,
// the gorestful handler (used for the API) which falls through to the nonGoRestful handler on unregistered paths,
// and the nonGoRestful handler (which can contain a fallthrough of its own)
// FullHandlerChain -&gt; Director -&gt; {GoRestfulContainer,NonGoRestfulMux} based on inspection of registered web services
type APIServerHandler struct {
	// FullHandlerChain is the one that is eventually served with.  It should include the full filter
	// chain and then call the Director.
	FullHandlerChain http.Handler
	// The registered APIs.  InstallAPIs uses this.  Other servers probably shouldn't access this directly.
	GoRestfulContainer *restful.Container
	// NonGoRestfulMux is the final HTTP handler in the chain.
	// It comes after all filters and the API handling
	// This is where other servers can attach handler to various parts of the chain.
	NonGoRestfulMux *mux.PathRecorderMux
	// Other servers should only use this opaquely to delegate to an API server.
	Director http.Handler
}
</code></pre>

<p><code>DelegationTarget</code>(<em>DelegationTarget is an interface which allows for composition of API servers with top level handling that works as expected.</em>)是一个<code>interface</code>，是构成方法名<code>CreateServerChain</code>中ServerChain的结构，结构体内定义了<code>NextDelegate()</code>方法，返回chain中的下一个<code>DelegationTarget</code>，由它串起了多个api servers。(为什么会有多个api server从后面代码中可以看到。)</p>

<h2 id="createserverchain">CreateServerChain</h2>

<pre><code class="language-golang">// CreateServerChain creates the apiservers connected via delegation.
func CreateServerChain(runOptions *options.ServerRunOptions, stopCh &lt;-chan struct{}) (*genericapiserver.GenericAPIServer, error) {}
</code></pre>

<p><code>CreateServerChain()</code>方法中，先后执行了<code>CreateNodeDialer</code>, <code>CreateKubeAPIServerConfig</code>, <code>createAPIExtensionsConfig</code>, <code>createAPIExtensionsServer</code>, <code>CreateKubeAPIServer</code>, <code>createAggregatorConfig</code>, <code>createAggregatorServer</code>几个方法，根据方法名可以看出启动apiserver的流程。</p>

<ul>
<li><p><code>CreateNodeDialer</code>(<em>CreateNodeDialer creates the dialer infrastructure to connect to the nodes</em>), add SSH Key, 返回一个<code>tunneler.Tunneler</code>, 可以通过创建到node节点的SSH连接。</p></li>

<li><p><code>CreateKubeAPIServerConfig</code>(<em>creates all the resources for running the API server, but runs none of them</em>), 创建出所有apiserver所需的配置和资源，包括配置的Validate，命令行参数解析，openapi/swagger配置，StorageFactory,clientset, informer, serviceResolver 等资源的创建。</p></li>

<li><p><code>createAPIExtensionsConfig</code>, 传入由上一步生成的配置<code>*kubeAPIServerConfig.GenericConfig</code>和 informer, 通过<code>apiextensionscmd.NewCRDRESTOptionsGetter(etcdOptions)</code>初始化<code>ExtraConfig.CRDRESTOptionsGetter</code>并创建 apiextensionsConfig 返回。</p></li>

<li><p><code>createAPIExtensionsServer</code>, 通过上一步生成的<code>apiExtensionsConfig</code>，通过一个<code>genericapiserver.EmptyDelegate</code>创建 apiExtensionsServer。返回 apiserver 的是一个<code>apiextensionsapiserver.CustomResourceDefinitions</code>结构体。其中生成 CustomResourceDefinitions 结构体的 New() 方法，真正将 CRD 接口添加到<code>apiGroupInfo.VersionedResourcesStorageMap</code>中，并注册到 go-resetful 的 webService，同时会通过<code>AddPostStartHook</code>添加启动后hook，启动informer(事件监听)和<code>crdController</code>, <code>namingController</code>, <code>finalizingController</code>三个 Controler 监听 CRD Resource 的变化。</p></li>

<li><p><code>CreateKubeAPIServer</code>(<em>creates and wires a workable kube-apiserver</em>), 通过以上几步生成的 apiserver 配置，通过<code>createAPIExtensionsServer</code>生成的<code>DelegationTarget</code>创建 apiserver 实例(<em>master.Master</em>)。这个过程中会 install kubernetes 的 core api 并 启动 BootStrapController(<em>a controller for watching the core capabilities of the master</em>),  install nodeTunneler 并添加<code>ca-registration</code>的 PostStartHook。</p></li>

<li><p><code>createAggregatorConfig</code>, 通过上面生成的 apiserver 配置生成 AggregatorConfig。(代码中只是浅拷贝一份<code>kubeAPIServerConfig.GenericConfig</code>并添加了 Proxy 相关的 ExtraConfig 到返回的<code>*aggregatorapiserver.Config</code>结构体中。)</p></li>

<li><p><code>createAggregatorServer</code>, 生成 AggregatorServer(*Aggregator for Kubernetes-style API servers: dynamic registration, discovery summarization, secure proxy
*)。这个过程中，会启动<code>apiserviceRegistrationController</code>, <code>availableController</code> 去监听 api service 资源，完成 api service 的发现和注册。</p></li>
</ul>

<p>这里解释一下 aggregator, 这是 kubernetes 为了增强 apiserver 的扩展性，方便用户开发自己的 api服务而开发的机制。它允许k8s的开发人员编写一个自己的服务，可以把这个服务注册到k8s的api里面，这样，就像k8s自己的api一样，你的服务只要运行在k8s集群里面，k8s 的Aggregate通过service名称就可以转发到你写的service里面去了。<br />
&gt;Aggregated（聚合的）API server是为了将原来的API server这个巨石（monolithic）应用给拆分成，为了方便用户开发自己的API server集成进来，而不用直接修改kubernetes官方仓库的代码，这样一来也能将API server解耦，方便用户使用实验特性。这些API server可以跟core API server无缝衔接，使用kubectl也可以管理它们。</p>

<p>到这里， apiserver的启动就基本完成了。<br />
下面主要分析下以上几个流程中<code>CreateKubeAPIServerConfig</code>和<code>CreateKubeAPIServer</code>两个方法，这也是创建出核心的apiserver 和真正执行k8s core api 注册的过程。</p>

<h2 id="createkubeapiserverconfig">CreateKubeAPIServerConfig</h2>

<pre><code class="language-golang">kubeAPIServerConfig, sharedInformers, versionedInformers, insecureServingOptions, serviceResolver, err := CreateKubeAPIServerConfig(runOptions, nodeTunneler, proxyTransport)

// CreateKubeAPIServerConfig creates all the resources for running the API server, but runs none of them
func CreateKubeAPIServerConfig(s *options.ServerRunOptions, nodeTunneler tunneler.Tunneler, proxyTransport *http.Transport) (*master.Config, informers.SharedInformerFactory, clientgoinformers.SharedInformerFactory, *kubeserver.InsecureServingInfo, aggregatorapiserver.ServiceResolver, error) {}
</code></pre>

<p>方法的注释是 创建为了运行API server所需的所有资源，但是不会运行。就是说，这个方法负责创建后面启动的apiserver所需的所有配置及相关类的初始化。通过返回参数看，这些资源至少包括apiserver的配置, <code>SharedInformerFactory</code>(<em>provides shared informers for resources in all known API group versions</em>), <code>InsecureServingInfo</code>(<em>is required to serve http.  HTTP does NOT include authentication or authorization.</em>), <code>ServiceResolver</code>(<em>knows how to get a URL given a service</em>)。</p>

<h3 id="主要流程">主要流程</h3>

<p>CreateKubeAPIServerConfig 首先是通过 <code>defaultOptions</code> 方法 在创建真正的 apiserver配置前将 options 中的参数以默认值补全，并对参数进行<code>Validate</code>, 然后通过<code>BuildGenericConfig</code>方法，根据 options 创建<code>*genericapiserver.Config</code>, 同时 <code>SharedInformer</code>和<code>ServiceResolver</code>都是在这个方法中创建的。
<code>BuildGenericConfig</code>方法中调用了很多<code>ApplyTo</code>方法，作用是将 options 中的各项配置参数解析到生成的config中, 在这个方法中还创建了<code>[]admission.PluginInitializer</code>。<br />
在这之后还有一个重要的方法是<code>BuildStorageFactory</code>，创建StorageFactory的时候需要传入 etcd 相关的配置。<code>Storage</code>是apiserver中一个很重要的概念，通过它执行对具体资源对象的操作，如对 POD 的 CRUD 等操作就是通过 <code>PodStorage</code>对象进行并连接到后端的 etcd 的。（同时 Storage 也是和 对应资源对象的 API 对应，后面installAPI的时候也是通过 Storage 来注册 API 路由的。）<br />
最后，配置默认的ServiceIPRange 和 获取 CA 证书等配置，将上面创建的配置注入一个<code>&amp;master.Config</code>实例并返回。</p>

<h3 id="serviceresolver">ServiceResolver</h3>

<p>ServiceResolver的定义及创建方法如下，通过 SharedInformer 的 lister 方法监听 kubernetes Service 资源的变化，实现获取 Service 的 URL 的功能。</p>

<pre><code class="language-golang">serviceResolver = aggregatorapiserver.NewClusterIPServiceResolver(
			versionedInformers.Core().V1().Services().Lister(),
		)

// A ServiceResolver knows how to get a URL given a service.
type ServiceResolver interface {
	ResolveEndpoint(namespace, name string) (*url.URL, error)
}
</code></pre>

<h3 id="sharedinformer">SharedInformer</h3>

<p>CreateKubeAPIServerConfig 返回两个<code>SharedInformerFactory</code>, 实际上结构体的定义完全相同，区别是定义在不同的包内，<code>informers.SharedInformerFactory</code>定义在 kubernetes 内部的pkg下，而<code>clientgoinformers.SharedInformerFactory</code>定义在 client-go 中，因此创建的时候，前者是通过<code>internalclientset</code>创建出的clientset创建，而后者是通过client-go的clientset创建，用来创建两者的配置是完全相同的。(第一次阅读，比较疑惑为什么需要两个clientset。猜测是一个用来内部通信，一个是用来外部通信。后面有时间的话，会再具体研究下。)<br />
<code>SharedInformerFactory</code>定义如下：</p>

<pre><code class="language-golang">// SharedInformerFactory provides shared informers for resources in all known
// API group versions.
type SharedInformerFactory interface {
	internalinterfaces.SharedInformerFactory
	ForResource(resource schema.GroupVersionResource) (GenericInformer, error)
	WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool

	Admissionregistration() admissionregistration.Interface
	Apps() apps.Interface
	Autoscaling() autoscaling.Interface
	Batch() batch.Interface
	Certificates() certificates.Interface
	Core() core.Interface
	Extensions() extensions.Interface
	Networking() networking.Interface
	Policy() policy.Interface
	Rbac() rbac.Interface
	Scheduling() scheduling.Interface
	Settings() settings.Interface
	Storage() storage.Interface
}
</code></pre>

<p>SharedInformerFactory为所有API group versions提供shared informers, shared informer又是什么呢？定义如下：</p>

<pre><code class="language-golang">// SharedInformer has a shared data cache and is capable of distributing notifications for changes
// to the cache to multiple listeners who registered via AddEventHandler. If you use this, there is
// one behavior change compared to a standard Informer.  When you receive a notification, the cache
// will be AT LEAST as fresh as the notification, but it MAY be more fresh.  You should NOT depend
// on the contents of the cache exactly matching the notification you've received in handler
// functions.  If there was a create, followed by a delete, the cache may NOT have your item.  This
// has advantages over the broadcaster since it allows us to share a common cache across many
// controllers. Extending the broadcaster would have required us keep duplicate caches for each
// watch.
type SharedInformer interface {
	// AddEventHandler adds an event handler to the shared informer using the shared informer's resync
	// period.  Events to a single handler are delivered sequentially, but there is no coordination
	// between different handlers.
	AddEventHandler(handler ResourceEventHandler)
	// AddEventHandlerWithResyncPeriod adds an event handler to the shared informer using the
	// specified resync period.  Events to a single handler are delivered sequentially, but there is
	// no coordination between different handlers.
	AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration)
	// GetStore returns the Store.
	GetStore() Store
	// GetController gives back a synthetic interface that &quot;votes&quot; to start the informer
	GetController() Controller
	// Run starts the shared informer, which will be stopped when stopCh is closed.
	Run(stopCh &lt;-chan struct{})
	// HasSynced returns true if the shared informer's store has synced.
	HasSynced() bool
	// LastSyncResourceVersion is the resource version observed when last synced with the underlying
	// store. The value returned is not synchronized with access to the underlying store and is not
	// thread-safe.
	LastSyncResourceVersion() string
}
</code></pre>

<p>可以通过先两篇文章了解下SharedInformer,
<a href="https://blog.csdn.net/weixin_42663840/article/details/81699303">https://blog.csdn.net/weixin_42663840/article/details/81699303</a><br />
<a href="https://www.kubernetes.org.cn/2693.html">https://www.kubernetes.org.cn/2693.html</a><br />
简单来说，SharedInformer 有一个共享数据的cache, 并能够将 cache 的变化分发给多个 listener, 这些 listener 都是通过 <code>AddEventHandler</code> 方法注册到 SharedInformer。Informer 在初始化的时，先调用 Kubernetes List API 到 ETCD获得某种 resource 的全部 Object，缓存在内存中; 然后，调用 Watch API 去 watch 这种 resource，去维护这份缓存; 最后，Informer 就不再调用 Kubernetes 的任何 API。</p>

<h2 id="createkubeapiserver">CreateKubeAPIServer</h2>

<pre><code class="language-golang">kubeAPIServer, err := CreateKubeAPIServer(kubeAPIServerConfig, apiExtensionsServer.GenericAPIServer, sharedInformers, versionedInformers)

// CreateKubeAPIServer creates and wires a workable kube-apiserver
func CreateKubeAPIServer(kubeAPIServerConfig *master.Config, delegateAPIServer genericapiserver.DelegationTarget, sharedInformers informers.SharedInformerFactory, versionedInformers clientgoinformers.SharedInformerFactory) (*master.Master, error) {}
</code></pre>

<p>方法的注释 创建并装配一个可工作的 kube-apiserver, 到这里，一个真正可运行的apiserver实例就创建完成了。可以看到返回的 APIServer 类型是<code>*master.Master</code>，传入的就是之前CreateKubeAPIServer返回的配置和资源，加上delegateAPIServer。这是kubernetes组合多个 apiserver 的机制。</p>

<h3 id="主要流程-1">主要流程</h3>

<p>生成 kubeAPIServer 的是<code>kubeAPIServerConfig.Complete(versionedInformers).New(delegateAPIServer)</code>方法。在这个方法中，又调用了<code>c.GenericConfig.New(&quot;kube-apiserver&quot;, delegationTarget)</code>创建一个APIServer，并生成 Handler chain 和传入的<code>delegateAPIServer</code>组合起来；接着会新建<code>*master.Master</code>实例 <code>m</code>，并将<code>c.GenericConfig.New</code> 返回的 APIServer 赋值给 <code>m.GenericAPIServer</code>, 这个<code>m</code>也是<code>CreateKubeAPIServer</code>方法最终要返回的 APISever 实例。最后要做的就是执行<code>m.InstallLegacyAPI</code>, <code>m.InstallAPIs</code>注册 API 接口，添加 PostStartHook 然后将<code>m</code>返回。</p>

<h3 id="c-genericconfig-new">c.GenericConfig.New</h3>

<pre><code class="language-golang">// New creates a new server which logically combines the handling chain with the passed server.
// name is used to differentiate for logging.
func (c completedConfig) New(name string, delegationTarget DelegationTarget) (*GenericAPIServer, error) {}
</code></pre>

<p>首先通过<code>apiServerHandler := NewAPIServerHandler(name, c.RequestContextMapper, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())</code>创建出一个<code>APIServerHandler</code>实例，结构体定义上面已经贴过了。<br />
NewAPIServerHandler 方法中，创建了<code>nonGoRestfulMux</code>和<code>gorestfulContainer</code>, 并给<code>gorestfulContainer</code>添加了几个默认Handler(NotFoundHandler, RecoverHandler, ServiceErrorHandler), 再这两者注入到一个 director 实例中，director 有一个 <code>ServeHTTP</code>, 用来最终启动 http 服务, 最后将director 赋值给 <code>APIServerHandler.Director</code>, 通过调用<code>c.BuildHandlerChainFunc(director, c.Config)</code>装饰<code>director</code>并赋值给<code>APIServerHandler.FullHandlerChain</code>最后返回。<br />
接着创建一个<code>GenericAPIServer</code>实例<code>s</code>，并将 NewAPIServerHandler 方法中返回的<code>apiServerHandler</code>赋值给<code>s.Handler</code>和<code>s.listedPathProvider</code>, 将传入的<code>delegationTarget</code>(即delegated apiserver) 中配置的 Hooks 和 HealthzCheckers 传递<code>s</code>, 并合并<code>s</code>和<code>delegationTarget</code>的 listedPathProvider(<em>an interface for providing paths that should be reported at /</em>), 最后执行<code>installAPI(s, c.Config)</code>安装 API 并返回<code>s</code>。</p>

<h4 id="director">director</h4>

<p>如下是<code>BuildHandlerChainFunc</code>和<code>*master.Config</code>中默认的方法，可以看到是不断追加 handler 方法到 Handler 中。</p>

<pre><code class="language-golang">// BuildHandlerChainFunc allows you to build custom handler chains by decorating the apiHandler.
BuildHandlerChainFunc func(apiHandler http.Handler, c *Config) (secure http.Handler)

// default BuildHandlerChainFunc
func DefaultBuildHandlerChain(apiHandler http.Handler, c *Config) http.Handler {
	handler := genericapifilters.WithAuthorization(apiHandler, c.RequestContextMapper, c.Authorizer, c.Serializer)
	handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.RequestContextMapper, c.LongRunningFunc)
	handler = genericapifilters.WithImpersonation(handler, c.RequestContextMapper, c.Authorizer, c.Serializer)
	if utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) {
		handler = genericapifilters.WithAudit(handler, c.RequestContextMapper, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)
	} else {
		handler = genericapifilters.WithLegacyAudit(handler, c.RequestContextMapper, c.LegacyAuditWriter)
	}
	failedHandler := genericapifilters.Unauthorized(c.RequestContextMapper, c.Serializer, c.SupportsBasicAuth)
	if utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) {
		failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.RequestContextMapper, c.AuditBackend, c.AuditPolicyChecker)
	}
	handler = genericapifilters.WithAuthentication(handler, c.RequestContextMapper, c.Authenticator, failedHandler)
	handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, nil, nil, nil, &quot;true&quot;)
	handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.RequestContextMapper, c.LongRunningFunc, c.RequestTimeout)
	handler = genericfilters.WithWaitGroup(handler, c.RequestContextMapper, c.LongRunningFunc, c.HandlerChainWaitGroup)
	handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver, c.RequestContextMapper)
	handler = apirequest.WithRequestContext(handler, c.RequestContextMapper)
	handler = genericfilters.WithPanicRecovery(handler)
	return handler
}
</code></pre>

<p>如下是<code>director</code>的定义及<code>ServeHTTP</code>方法，先匹配 path 是否是gorestful中的路径，是的话通过<code>goRestfulContainer.Dispatch(w, req)</code>分发到对应 handler 处理请求，不匹配的话就通过<code>nonGoRestfulMux</code>分发处理。</p>

<pre><code class="language-golang">type director struct {
	name               string
	goRestfulContainer *restful.Container
	nonGoRestfulMux    *mux.PathRecorderMux
}

func (d director) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	path := req.URL.Path

	// check to see if our webservices want to claim this path
	for _, ws := range d.goRestfulContainer.RegisteredWebServices() {
		switch {
		case ws.RootPath() == &quot;/apis&quot;:
			// if we are exactly /apis or /apis/, then we need special handling in loop.
			// normally these are passed to the nonGoRestfulMux, but if discovery is enabled, it will go directly.
			// We can't rely on a prefix match since /apis matches everything (see the big comment on Director above)
			if path == &quot;/apis&quot; || path == &quot;/apis/&quot; {
				glog.V(5).Infof(&quot;%v: %v %q satisfied by gorestful with webservice %v&quot;, d.name, req.Method, path, ws.RootPath())
				// don't use servemux here because gorestful servemuxes get messed up when removing webservices
				// TODO fix gorestful, remove TPRs, or stop using gorestful
				d.goRestfulContainer.Dispatch(w, req)
				return
			}

		case strings.HasPrefix(path, ws.RootPath()):
			// ensure an exact match or a path boundary match
			if len(path) == len(ws.RootPath()) || path[len(ws.RootPath())] == '/' {
				glog.V(5).Infof(&quot;%v: %v %q satisfied by gorestful with webservice %v&quot;, d.name, req.Method, path, ws.RootPath())
				// don't use servemux here because gorestful servemuxes get messed up when removing webservices
				// TODO fix gorestful, remove TPRs, or stop using gorestful
				d.goRestfulContainer.Dispatch(w, req)
				return
			}
		}
	}

	// if we didn't find a match, then we just skip gorestful altogether
	glog.V(5).Infof(&quot;%v: %v %q satisfied by nonGoRestful&quot;, d.name, req.Method, path)
	d.nonGoRestfulMux.ServeHTTP(w, req)
}
</code></pre>

<h4 id="listedpathprovider">ListedPathProvider</h4>

<pre><code class="language-golang">// ListedPathProvider is an interface for providing paths that should be reported at /.
type ListedPathProvider interface {
	// ListedPaths is an alphabetically sorted list of paths to be reported at /.
	ListedPaths() []string
}
</code></pre>

<h4 id="installapi">installAPI</h4>

<p>这里的 installAPI 方法如下，只根据配置安装了 Index, SwaggerUI, Profiling, Metrics 等 API 到 <code>NonGoRestfulMux</code>, Version(<code>/version</code>) 到 <code>GoRestfulContainer</code>, 核心的 API 还没有安装。</p>

<h3 id="m-installlegacyapi">m.InstallLegacyAPI</h3>

<pre><code class="language-golang">m.InstallLegacyAPI(&amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider)

func (m *Master) InstallLegacyAPI(c *completedConfig, restOptionsGetter generic.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider) {}
</code></pre>

<p>用于注册<code>/api</code>下的 API, 即core api。首先调用<code>legacyRESTStorageProvider.NewLegacyRESTStorage</code>创建<code>legacyRESTStorage</code>, 如果配置中<code>EnableCoreControllers</code>为<code>True</code>的话，创建<code>BootStrapController</code>并在 <code>m</code>的 PostStartHook 和 dPostStartHook 中添加启动和停止。最后执行<code>m.GenericAPIServer.InstallLegacyAPIGroup</code>安装 LegacyAPIGroup。</p>

<h4 id="newlegacyreststorage">NewLegacyRESTStorage</h4>

<pre><code class="language-golang">legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)

func (c LegacyRESTStorageProvider) NewLegacyRESTStorage(restOptionsGetter generic.RESTOptionsGetter) (LegacyRESTStorage, genericapiserver.APIGroupInfo, error) {}
</code></pre>

<p>这个方法返回两个结构体，<code>LegacyRESTStorage</code>和<code>genericapiserver.APIGroupInfo</code>, 其中最重要的是 APIGroupInfo。APIGroupInfo 中，有一个<code>VersionedResourcesStorageMap</code>, 是API 版本到 Storage 资源的 map 关系，保存了不同版本的所有 Storage。下面贴出了两个结构体的定义。
首先会初始化一个 APIGroupInfo 实例<code>apiGroupInfo</code>, 接着会调用不同 Storage 资源的<code>NewREST</code>方法创建 Storage, 如: <code>eventStorage</code>, <code>configMapStorage</code>, <code>namespaceStorage</code>, <code>serviceRESTStorage</code>, <code>podStorage</code>等。<code>NewREST</code>方法返回一个 REST 结构体, 而 REST 结构体中，保存了<code>*genericregistry.Store</code>, 这个 Store 结构体提供了对应资源的 CRUD 等操作的方法，所有对资源的操作通过 Store 来访问到后端的 ETCD。其中 pod, node 和 service 对应的操作比较多，涉及 Status 的存储和更新, 所以 Storage 创建过程也较为复杂。尤其是 pod, 不仅涉及到本身和状态的存储和更新，还涉及到日志 proxy 等操作，所以单独封装了一个 PodStorage 结构体，其中包含了多种不同的 Store, 例如涉及到日志的<code>LogREST</code>需要传入 KubeletConnectionInfo, 涉及到 proxy 的 ProxyREST 需要传入 ProxyTransport等，每种 Store 都提供了对应资源的操作方法，如获取日志，建立连接等。这部分代码在<code>k8s.io\kubernetes\pkg\registry\core\rest\storage_core.go</code>, 有关 Pod 和 Service 的 Storage 创建及不同 Storage 对应的方法可以看一下。<br />
最后，所有 Storage 创建完后，会构建一个<code>restStorageMap</code>(具体内容会在下面贴出)，这个 map 最后会赋给<code>apiGroupInfo.VersionedResourcesStorageMap[&quot;v1&quot;]</code>, 即 core API v1版本的所有资源都可以在这个 map 资源中找到。</p>

<pre><code class="language-golang">// LegacyRESTStorage returns stateful information about particular instances of REST storage to
// master.go for wiring controllers.
// TODO remove this by running the controller as a poststarthook
type LegacyRESTStorage struct {
	ServiceClusterIPAllocator rangeallocation.RangeRegistry
	ServiceNodePortAllocator  rangeallocation.RangeRegistry
}

// Info about an API group.
type APIGroupInfo struct {
	GroupMeta apimachinery.GroupMeta
	// Info about the resources in this group. Its a map from version to resource to the storage.
	VersionedResourcesStorageMap map[string]map[string]rest.Storage
	// OptionsExternalVersion controls the APIVersion used for common objects in the
	// schema like api.Status, api.DeleteOptions, and metav1.ListOptions. Other implementors may
	// define a version &quot;v1beta1&quot; but want to use the Kubernetes &quot;v1&quot; internal objects.
	// If nil, defaults to groupMeta.GroupVersion.
	// TODO: Remove this when https://github.com/kubernetes/kubernetes/issues/19018 is fixed.
	OptionsExternalVersion *schema.GroupVersion
	// MetaGroupVersion defaults to &quot;meta.k8s.io/v1&quot; and is the scheme group version used to decode
	// common API implementations like ListOptions. Future changes will allow this to vary by group
	// version (for when the inevitable meta/v2 group emerges).
	MetaGroupVersion *schema.GroupVersion

	// Scheme includes all of the types used by this group and how to convert between them (or
	// to convert objects from outside of this group that are accepted in this API).
	// TODO: replace with interfaces
	Scheme *runtime.Scheme
	// NegotiatedSerializer controls how this group encodes and decodes data
	NegotiatedSerializer runtime.NegotiatedSerializer
	// ParameterCodec performs conversions for query parameters passed to API calls
	ParameterCodec runtime.ParameterCodec
}
</code></pre>

<pre><code class="language-golang">// restStorageMap
restStorageMap := map[string]rest.Storage{
	&quot;pods&quot;:             podStorage.Pod,
	&quot;pods/attach&quot;:      podStorage.Attach,
	&quot;pods/status&quot;:      podStorage.Status,
	&quot;pods/log&quot;:         podStorage.Log,
	&quot;pods/exec&quot;:        podStorage.Exec,
	&quot;pods/portforward&quot;: podStorage.PortForward,
	&quot;pods/proxy&quot;:       podStorage.Proxy,
	&quot;pods/binding&quot;:     podStorage.Binding,
	&quot;bindings&quot;:         podStorage.Binding,
	&quot;podTemplates&quot;: podTemplateStorage,
	&quot;replicationControllers&quot;:        controllerStorage.Controller,
	&quot;replicationControllers/status&quot;: controllerStorage.Status,
	&quot;services&quot;:        serviceRest.Service,
	&quot;services/proxy&quot;:  serviceRest.Proxy,
	&quot;services/status&quot;: serviceStatusStorage,
	&quot;endpoints&quot;: endpointsStorage,
	&quot;nodes&quot;:        nodeStorage.Node,
	&quot;nodes/status&quot;: nodeStorage.Status,
	&quot;nodes/proxy&quot;:  nodeStorage.Proxy,
	&quot;events&quot;: eventStorage,
	&quot;limitRanges&quot;:                   limitRangeStorage,
	&quot;resourceQuotas&quot;:                resourceQuotaStorage,
	&quot;resourceQuotas/status&quot;:         resourceQuotaStatusStorage,
	&quot;namespaces&quot;:                    namespaceStorage,
	&quot;namespaces/status&quot;:             namespaceStatusStorage,
	&quot;namespaces/finalize&quot;:           namespaceFinalizeStorage,
	&quot;secrets&quot;:                       secretStorage,
	&quot;serviceAccounts&quot;:               serviceAccountStorage,
	&quot;persistentVolumes&quot;:             persistentVolumeStorage,
	&quot;persistentVolumes/status&quot;:      persistentVolumeStatusStorage,
	&quot;persistentVolumeClaims&quot;:        persistentVolumeClaimStorage,
	&quot;persistentVolumeClaims/status&quot;: persistentVolumeClaimStatusStorage,
	&quot;configMaps&quot;:                    configMapStorage,
	&quot;componentStatuses&quot;: componentstatus.NewStorage(componentStatusStorage{c.StorageFactory}.serversToValidate),
}
</code></pre>

<h4 id="installlegacyapigroup">InstallLegacyAPIGroup</h4>

<pre><code class="language-golang">m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo)

func (s *GenericAPIServer) InstallLegacyAPIGroup(apiPrefix string, apiGroupInfo *APIGroupInfo) error {
	if !s.legacyAPIGroupPrefixes.Has(apiPrefix) {
		return fmt.Errorf(&quot;%q is not in the allowed legacy API prefixes: %v&quot;, apiPrefix, s.legacyAPIGroupPrefixes.List())
	}
	if err := s.installAPIResources(apiPrefix, apiGroupInfo); err != nil {
		return err
	}

	// setup discovery
	apiVersions := []string{}
	for _, groupVersion := range apiGroupInfo.GroupMeta.GroupVersions {
		apiVersions = append(apiVersions, groupVersion.Version)
	}
	// Install the version handler.
	// Add a handler at /&lt;apiPrefix&gt; to enumerate the supported api versions.
	s.Handler.GoRestfulContainer.Add(discovery.NewLegacyRootAPIHandler(s.discoveryAddresses, s.Serializer, apiPrefix, apiVersions, s.requestContextMapper).WebService())
	return nil
}
</code></pre>

<p>整个方法如上，主要两步，首先调用 installAPIResources(<em>is a private method for installing the REST storage backing each api groupversionresource</em>) 安装 API。<br />
installAPIResources 会遍历<code>apiGroupInfo</code>下的所有 groupVersion, 然后通过<code>s.getAPIGroupVersion</code>得到该 version 下所有的 Storage, 即上面<code>apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version]</code> map 中所对应的所有 Storage。并通过<code>InstallREST</code>注册到 REST API 的 Handler 中。InstallREST方法如下，在 <code>installer.Install()</code>方法中, 以上面的<code>restStorageMap</code>的 key 为 path, 将所有 Storage 通过<code>registerResourceHandlers</code>(<em>具体方法在 k8s.io\apiserver\pkg\endpoints\installer.go, 一个近700行的 swich-case 的方法，有兴趣可以看下。</em>)方法注册到 gorestful 的 WebService Route中，并返回一个<code>*metav1.APIResource</code>对象，Install 方法会返回所有 Storage 的生成的 APIResources 和注册到的 WebService。<br />
接着获取 GroupVersions 中的所有版本并注册到 <code>GoRestfulContainer</code> 中(adds a service to return the supported api versions at the legacy /api), 返回可支持 API 版本。</p>

<pre><code class="language-golang">// InstallREST registers the REST handlers (storage, watch, proxy and redirect) into a restful Container.
// It is expected that the provided path root prefix will serve all operations. Root MUST NOT end
// in a slash.
func (g *APIGroupVersion) InstallREST(container *restful.Container) error {
	prefix := path.Join(g.Root, g.GroupVersion.Group, g.GroupVersion.Version)
	installer := &amp;APIInstaller{
		group:                        g,
		prefix:                       prefix,
		minRequestTimeout:            g.MinRequestTimeout,
		enableAPIResponseCompression: g.EnableAPIResponseCompression,
	}

	apiResources, ws, registrationErrors := installer.Install()
	versionDiscoveryHandler := discovery.NewAPIVersionHandler(g.Serializer, g.GroupVersion, staticLister{apiResources}, g.Context)
	versionDiscoveryHandler.AddToWebService(ws)
	container.Add(ws)
	return utilerrors.NewAggregate(registrationErrors)
}

// Install handlers for API resources.
func (a *APIInstaller) Install() ([]metav1.APIResource, *restful.WebService, []error) {
	var apiResources []metav1.APIResource
	var errors []error
	ws := a.newWebService()

	proxyHandler := (&amp;handlers.ProxyHandler{
		Prefix:     a.prefix + &quot;/proxy/&quot;,
		Storage:    a.group.Storage,
		Serializer: a.group.Serializer,
		Mapper:     a.group.Context,
	})

	// Register the paths in a deterministic (sorted) order to get a deterministic swagger spec.
	paths := make([]string, len(a.group.Storage))
	var i int = 0
	for path := range a.group.Storage {
		paths[i] = path
		i++
	}
	sort.Strings(paths)
	for _, path := range paths {
		apiResource, err := a.registerResourceHandlers(path, a.group.Storage[path], ws, proxyHandler)
		if err != nil {
			errors = append(errors, fmt.Errorf(&quot;error in registering resource: %s, %v&quot;, path, err))
		}
		if apiResource != nil {
			apiResources = append(apiResources, *apiResource)
		}
	}
	return apiResources, ws, errors
}
</code></pre>

<h3 id="m-installapis">m.InstallAPIs</h3>

<pre><code class="language-golang">m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...)

// InstallAPIs will install the APIs for the restStorageProviders if they are enabled.
func (m *Master) InstallAPIs(apiResourceConfigSource serverstorage.APIResourceConfigSource, restOptionsGetter generic.RESTOptionsGetter, restStorageProviders ...RESTStorageProvider) {}
</code></pre>

<p>用于注册<code>/apis</code>下的 API。在调用 InstallAPIs 之前，会创建<code>/apis</code>下 Storage 的 <code>RESTStorageProvider</code>, 该 interface 的定义及创建在下面代码片段<code>1</code>贴出。<br />
每个 RESTStorageProvider, 都会有一个<code>NewRESTStorage</code>方法来创建对应资源的 Storage。调用 InstallAPIs 方法时，会将 restStorageProviders 列表传入。
InstallAPIs 会遍历传入的 restStorageProviders 列表，并调用每个 restStorageProvider 的 <code>NewRESTStorage</code>。<br />
<code>NewRESTStorage</code>方法, 会新建一个 APIGroupInfo, 然后针对 enable 的 API 版本, 调用 VXXStorage 获取对应版本的 ResourcesStorageMap 并存入 apiGroupInfo.VersionedResourcesStorageMap[VXX]中。用来获取 ResourcesStorageMap 的方法，和上面 InstallLegacyAPIGroup.NewLegacyRESTStorage 方法中一样，也是 <code>NewREST</code>, 具体逻辑也基本相同，返回一个 REST 结构体提供对资源的 CRUD 等操作。<br />
<code>NewRESTStorage</code>方法最终返回的 apiGroupInfo, 会被放入一个 apiGroupsInfo 列表，最后会遍历这个列表并针对每一个 apiGroupInfo 执行 <code>m.GenericAPIServer.InstallAPIGroup(&amp;apiGroupsInfo[i])</code>, 这部分逻辑和 InstallLegacyAPIGroup 一样，通过调用 installAPIResources 将 API 注册到 GoRestfulContainer 中，详细的可以对照上面的 InstallLegacyAPIGroup 的分析参考源码。</p>

<pre><code class="language-golang">// 代码片段 1
// RESTStorageProvider is a factory type for REST storage.
type RESTStorageProvider interface {
	GroupName() string
	NewRESTStorage(apiResourceConfigSource serverstorage.APIResourceConfigSource, restOptionsGetter generic.RESTOptionsGetter) (genericapiserver.APIGroupInfo, bool)
}

// The order here is preserved in discovery.
	// If resources with identical names exist in more than one of these groups (e.g. &quot;deployments.apps&quot;&quot; and &quot;deployments.extensions&quot;),
	// the order of this list determines which group an unqualified resource name (e.g. &quot;deployments&quot;) should prefer.
	// This priority order is used for local discovery, but it ends up aggregated in `k8s.io/kubernetes/cmd/kube-apiserver/app/aggregator.go
	// with specific priorities.
	// TODO: describe the priority all the way down in the RESTStorageProviders and plumb it back through the various discovery
	// handlers that we have.
	restStorageProviders := []RESTStorageProvider{
		authenticationrest.RESTStorageProvider{Authenticator: c.GenericConfig.Authenticator},
		authorizationrest.RESTStorageProvider{Authorizer: c.GenericConfig.Authorizer, RuleResolver: c.GenericConfig.RuleResolver},
		autoscalingrest.RESTStorageProvider{},
		batchrest.RESTStorageProvider{},
		certificatesrest.RESTStorageProvider{},
		extensionsrest.RESTStorageProvider{},
		networkingrest.RESTStorageProvider{},
		policyrest.RESTStorageProvider{},
		rbacrest.RESTStorageProvider{Authorizer: c.GenericConfig.Authorizer},
		schedulingrest.RESTStorageProvider{},
		settingsrest.RESTStorageProvider{},
		storagerest.RESTStorageProvider{},
		// keep apps after extensions so legacy clients resolve the extensions versions of shared resource names.
		// See https://github.com/kubernetes/kubernetes/issues/42392
		appsrest.RESTStorageProvider{},
		admissionregistrationrest.RESTStorageProvider{},
		eventsrest.RESTStorageProvider{TTL: c.ExtraConfig.EventTTL},
	}
</code></pre>

<footer class=" footline" >
	
</footer>


        
        </div> 
        

      </div>

    <div id="navigation">
        
        
        
        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
        
        


	 
	 
    </div>

    </section>
    
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="/js/clipboard.min.js?1544703889"></script>
    <script src="/js/perfect-scrollbar.min.js?1544703889"></script>
    <script src="/js/perfect-scrollbar.jquery.min.js?1544703889"></script>
    <script src="/js/jquery.sticky.js?1544703889"></script>
    <script src="/js/featherlight.min.js?1544703889"></script>
    <script src="/js/html5shiv-printshiv.min.js?1544703889"></script>
    <script src="/js/highlight.pack.js?1544703889"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="/js/modernizr.custom.71422.js?1544703889"></script>
    <script src="/js/learn.js?1544703889"></script>
    <script src="/js/hugo-learn.js?1544703889"></script>

    <link href="/mermaid/mermaid.css?1544703889" type="text/css" rel="stylesheet" />
    <script src="/mermaid/mermaid.js?1544703889"></script>
    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
    

  </body>
</html>

