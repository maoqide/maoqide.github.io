<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cloud on Maoqide</title>
    <link>/cloud/</link>
    <description>Recent content in Cloud on Maoqide</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Dec 2018 15:39:05 +0800</lastBuildDate>
    
	<atom:link href="/cloud/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Building an Operator for Kubernetes With the Sample Controller</title>
      <link>/cloud/building-an-operator-for-kubernetes-with-the-sample-controller/</link>
      <pubDate>Sat, 16 Mar 2019 21:34:46 +0800</pubDate>
      
      <guid>/cloud/building-an-operator-for-kubernetes-with-the-sample-controller/</guid>
      <description>An Operator is an application-specific controller that extends the Kubernetes API to create, configure, and manage instances of complex stateful applications on behalf of a Kubernetes user.  Operator 是一个特定的应用程序的控制器，通过扩展 Kubernetes API 以代表 Kubernetes 用户创建，配置和管理复杂有状态应用程序的实例。
Operator 是一种软件，它结合了特定的领域知识并通过 CRD(Custom Resource Definition ) 机制扩展了Kubernetes API，使用户像管理 Kubernetes 的内置资源一样创建，配置和管理应用程序。Operator 管理整个集群中的多个实例，而不仅仅管理应用程序的单个实例。
[译] https://itnext.io/building-an-operator-for-kubernetes-with-the-sample-controller-b4204be9ad56
The sample-controller 创建示例的 operator 程序需要用到的第一个工具是 sample-controller, 可以在 https://github.com/kubernetes/sample-controller 找到。
这个项目实现了一个简单的 Foo 类型的 operator, 当创建一个自定义类型的对象 foo，operator 会创建一个 以几个公开的 docker 镜像和特定的副本数创建一个 Deployment。
要安装和编译它，需要确认你的 GOPATH，然后执行:</description>
    </item>
    
    <item>
      <title>Kube Scheduler 源码阅读</title>
      <link>/cloud/kube-scheduler-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 07 Mar 2019 20:00:30 +0800</pubDate>
      
      <guid>/cloud/kube-scheduler-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>NewSchedulerCommand() runCommand() opts.Config()	// create client &amp;amp; informer func Run(cc schedulerserverconfig.CompletedConfig, stopCh &amp;lt;-chan struct{}) error {} run := func(ctx context.Context) {} sched.Run() // Run begins watching and scheduling. It waits for cache to be synced, then starts a goroutine and returns immediately. func (sched *Scheduler) Run() {} go wait.Until(sched.scheduleOne, 0, sched.config.StopEverything) // scheduleOne does the entire scheduling workflow for a single pod. func (sched *Scheduler) scheduleOne() {} pod := sched.config.NextPod() sched.</description>
    </item>
    
    <item>
      <title>Controller Manager 源码阅读</title>
      <link>/cloud/controller-manager-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Sat, 23 Feb 2019 16:52:30 +0800</pubDate>
      
      <guid>/cloud/controller-manager-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>&lt;p&gt;k8s controller-manager 源码阅读笔记&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Apiserver 源码阅读</title>
      <link>/cloud/apiserver-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Wed, 21 Nov 2018 19:46:06 +0800</pubDate>
      
      <guid>/cloud/apiserver-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>&lt;p&gt;k8s apiserver 源码阅读笔记&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>阿里云主机搭建 K8S 集群</title>
      <link>/cloud/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BA-k8s-%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Wed, 14 Nov 2018 14:31:38 +0800</pubDate>
      
      <guid>/cloud/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BA-k8s-%E9%9B%86%E7%BE%A4/</guid>
      <description>&lt;p&gt;通过阿里云ECS实例搭建K8S集群&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>