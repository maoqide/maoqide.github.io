<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golangs on Maoqide</title>
    <link>/golang/</link>
    <description>Recent content in Golangs on Maoqide</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Dec 2018 16:29:32 +0800</lastBuildDate>
    
	<atom:link href="/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Goroutine Management In Golang</title>
      <link>/golang/goroutine/</link>
      <pubDate>Fri, 28 Dec 2018 16:29:32 +0800</pubDate>
      
      <guid>/golang/goroutine/</guid>
      <description>goroutine 是 go 的最重要特性之一，可以方便的实现并发编程。但是真正用起来，如果不多加注意，很容易造成 goroutine 的泄漏或者脱离管理，造成代码跑一段时间，就是产生大量无法回收的goroutine(可通过 pprof 查看)。最近学习整理了下 go 语言中管理 goroutine 的几种方法和一些最佳实践。
几点原则 go-best-practices-concurrency
在 github上的 go-best-practices 项目中，提到了几点最佳实践，这里记录下。
不要和 goroutine 失去联系(Don&amp;rsquo;t loose contact with your goroutines) 如何避免? 使用make(chan struct{})/sync.WaitGroup/context.Context或select。
你可能需要这样：
1. 当必要的时候可以*中断*创建的 goroutine。 2. 等待直到产生的所有 goroutine 都完成了。
 中断(Interruption)
可以用以下方式实现： 共享一个无缓冲的空结构体通道（make（chan struct {}）），由 goroutine 的创建者发出关闭信号以关闭。 一个可取消的context.Context。 确保你的 goroutine 使用select来不时检查他们的信号，而不会无限期地阻塞住。
 等待 goroutine 完成(Waiting for goroutines to finish)
实现的最简单方法是使用sync.WaitGroup。在创建 goroutine 之前，请确保调用了wg.Add(1)。在运行 goroutine 之后，但在它 return 之前，请确保wg.Done()。这种场景下，defer是很好的选择。
  不要用 WaitGroup 来计数多种类型的 goroutine(Don&amp;rsquo;t use wait groups to count more than one type of goroutine) 这里说的 gouroutine 的类型和被作为 gouroutine 调用的函数相关联，此函数可以是另一种类型的成员函数，可以是包中的命名函数，也可以是匿名函数。重要的一点是，你不应该在作为goroutine 调用的不同函数之间共享 WaitGroup。保持简单，如果你需要对一个不同类型的函数使用go关键字，创建一个新的 WaitGroup，并对它正确命名。</description>
    </item>
    
  </channel>
</rss>