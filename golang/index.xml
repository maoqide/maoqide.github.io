<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Maoqide</title>
    <link>/golang/</link>
    <description>Recent content in Golang on Maoqide</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Dec 2018 16:27:41 +0800</lastBuildDate>
    
	<atom:link href="/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang Mutex</title>
      <link>/golang/golang-mutex/</link>
      <pubDate>Mon, 11 Mar 2019 16:35:20 +0800</pubDate>
      
      <guid>/golang/golang-mutex/</guid>
      <description>golang 的sync包中有两种锁，互斥锁sync.Mutex 和读写锁sync.RWMutex。
sync.Mutex  Mutex 为互斥锁，Lock() 加锁，Unlock() 解锁
 使用 Lock() 加锁后，在使用Unlock()解锁前便不能再次对其进行加锁，否则会导致死锁
 在Lock()前使用Unlock()会导致 panic 异常
 适用于读写不确定场景，即读写次数没有明显的区别，并且只允许只有一个读或者写的场景
  sync.RWMutex  RWMutex 是单写多读锁，可以加多个读锁或者一个写锁
 读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁
 写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占
 适用于读多写少的场景
  Lock()/Unlock()  Lock() 加写锁，Unlock() 解写锁
 写锁权限高于读锁，有写锁时优先加写锁
 在 Lock() 之前使用 Unlock() 会导致 panic 异常
  RLock()/RUnlock()  RLock() 加读锁，RUnlock() 解读锁
 RLock() 加读锁时，如果存在写锁，则无法加读锁；当只有读锁或者没有锁时，可以加读锁，读锁可以加多个
 RUnlock() 解读锁，RUnlock() 撤销单次 RLock() 调用，对于其他同时存在的读锁没有作用</description>
    </item>
    
    <item>
      <title>Goroutine 的管理</title>
      <link>/golang/goroutine/</link>
      <pubDate>Fri, 28 Dec 2018 16:29:32 +0800</pubDate>
      
      <guid>/golang/goroutine/</guid>
      <description>goroutine 是 go 的最重要特性之一，可以方便的实现并发编程。但是真正用起来，如果不多加注意，很容易造成 goroutine 的泄漏或者脱离管理，造成代码跑一段时间，就是产生大量无法回收的goroutine(可通过 pprof 查看)。最近学习整理了下 go 语言中管理 goroutine 的几种方法和一些最佳实践。
几点原则 go-best-practices-concurrency
在 github上的 go-best-practices 项目中，提到了几点最佳实践，这里记录下。
不要和 goroutine 失去联系  Don&amp;rsquo;t loose contact with your goroutines
 如何避免? 使用make(chan struct{})/sync.WaitGroup/context.Context或select。
你可能需要这样：
1. 当必要的时候可以*中断*创建的 goroutine。
2. 等待直到产生的所有 goroutine 都完成了。
中断(Interruption)
可以用以下方式实现：
1. 共享一个无缓冲的空结构体通道（make（chan struct {}）），由 goroutine 的创建者发出关闭信号以关闭。
2. 一个可取消的context.Context。
3. 确保你的 goroutine 使用select来不时检查他们的信号，而不会无限期地阻塞住。
等待 goroutine 完成(Waiting for goroutines to finish)
实现的最简单方法是使用sync.WaitGroup。在创建 goroutine 之前，请确保调用了wg.Add(1)。在运行 goroutine 之后，但在它 return 之前，请确保wg.Done()。这种场景下，defer是很好的选择。
不要用 WaitGroup 来计数多种类型的 goroutine  Don&amp;rsquo;t use wait groups to count more than one type of goroutine</description>
    </item>
    
  </channel>
</rss>