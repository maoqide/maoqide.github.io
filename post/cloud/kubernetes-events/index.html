<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8" />

  
  <title>Kubernetes Events</title>

  
  
  <link href="//cdn.jsdelivr.net" rel="dns-prefetch">
  <link href="//cdnjs.cloudflare.com" rel="dns-prefetch">
  
  <link href="//at.alicdn.com" rel="dns-prefetch">
  
  <link href="//fonts.googleapis.com" rel="dns-prefetch">
  <link href="//fonts.gstatic.com" rel="dns-prefetch">
  <link href="///disqus.com" rel="dns-prefetch">
  <link href="//c.disquscdn.com" rel="dns-prefetch">
  
  <link href="//www.google-analytics.com" rel="dns-prefetch">
  <link href="//hm.baidu.com" rel="dns-prefetch">

  

  
  <meta name="author" content="Maoqide">
  <meta name="description" content="通过源码探究 kubernetes 如何记录和存储集群中的大量事件信息。
">

  
  
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@gohugoio">
    <meta name="twitter:title" content="Kubernetes Events">
    <meta name="twitter:description" content="通过源码探究 kubernetes 如何记录和存储集群中的大量事件信息。
">
    <meta name="twitter:image" content="/images/golang.svg">
  

  
  <meta property="og:type" content="article">
  <meta property="og:title" content="Kubernetes Events">
  <meta property="og:description" content="通过源码探究 kubernetes 如何记录和存储集群中的大量事件信息。
">
  <meta property="og:url" content="/post/cloud/kubernetes-events/">
  <meta property="og:image" content="/images/golang.svg">




<meta name="generator" content="Hugo 0.55.6">


<link rel="canonical" href="/post/cloud/kubernetes-events/">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">
<meta name="google-site-verification" content="moDctZ0TPe6VxisyOQD_1YWrlEXu3jHdB1go5ptHRn0">
<meta name="msvalidate.01" content="0498007A4CDA3EAB6CD23570479B29DA">





<meta name="theme-color" content="#02b875">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Maoqide">
<meta name="msapplication-tooltip" content="Maoqide">
<meta name='msapplication-navbutton-color' content="#02b875">
<meta name="msapplication-TileColor" content="#02b875">
<meta name="msapplication-TileImage" content="/icons/icon-144x144.png">
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-32x32.png">
<link rel="icon" sizes="192x192" href="/icons/icon-192x192.png">
<link rel="apple-touch-icon" href="/icons/icon-152x152.png">
<link rel="manifest" href="/manifest.json">


<link rel="preload" href="/styles/main-rendered.min.css" as="style">


<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="/images/golang.svg" as="image">
<link rel="preload" href="/images/square.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/images/square.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="/styles/main-rendered.min.css">


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.2/dist/medium-zoom.min.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video-js.min.css">



  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


</head>
  <body>
    <div class="suspension">
      <a role="button" aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden="true"></span></a>
      
        
	<a role="button" aria-label="Go to comments" title="Go to comments" class="to-comment" href="#disqus_thread"><span class="icon icon-comment" aria-hidden="true"></span></a>
        
      
    </div>
    
    
  <header class="site-header">
  <a href=""><img class="avatar" src="/images/golang.svg" alt="Avatar"></a>
  
  <h2 class="title"><a href="">Maoqide</a></h2>
  
  <p class="subtitle">~ Keep Learning ~</p>
  <button class="menu-toggle" type="button" aria-label="Main Menu" aria-expanded="false" tab-index="0">
    <span class="icon icon-menu" aria-hidden="true"></span>
  </button>

  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
          
          
           is-active">
          <a href="/">Home</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="/post/">Post</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"><li class="social-item">
          <a href="mailto:maoqidemail@gmail.com" title="Email" aria-label="Email">
            <span class="icon icon-email" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//github.com/maoqide" rel="me" title="GitHub" aria-label="GitHub">
	    <span class="icon icon-github" aria-hidden="true"></span>
          </a>
        </li></ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">Kubernetes Events</h1>
      <p class="post-meta">@Maoqide · Apr 25, 2020 · 18 min read</p>
    </header>
    <article class="post-content"><p>通过源码探究 kubernetes 如何记录和存储集群中的大量事件信息。</p>

<h1 id="一个-event-在-kubernetes-中的完整历程">一个 event 在 kubernetes 中的完整历程</h1>

<h2 id="从-kubelet-的-birthcry-开始">从 Kubelet 的 BirthCry 开始</h2>

<h3 id="birthcry">BirthCry</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// Kubelet BirthCry as example
</span><span style="color:#75715e">// BirthCry sends an event that the kubelet has started up.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">kl</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Kubelet</span>) <span style="color:#a6e22e">BirthCry</span>() {
	<span style="color:#75715e">// Make an event that kubelet restarted.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">kl</span>.<span style="color:#a6e22e">recorder</span>.<span style="color:#a6e22e">Eventf</span>(<span style="color:#a6e22e">kl</span>.<span style="color:#a6e22e">nodeRef</span>, <span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">EventTypeNormal</span>, <span style="color:#a6e22e">events</span>.<span style="color:#a6e22e">StartingKubelet</span>, <span style="color:#e6db74">&#34;Starting kubelet.&#34;</span>)
}

<span style="color:#75715e">// vendor/k8s.io/client-go/tools/record/event.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">EventRecorder</span> <span style="color:#66d9ef">interface</span> {}</code></pre></div>
<p>kubernetes 几乎每个组件都会发送事件信息，以 kubelet 为例，当 kubelet 启动时，会调用一个 BirthCry 方法，此方法会发送一个事件，方法命名非常形象，代表 kubelet 在启动。那么这个事件是如何发出的呢？<br />
通过源码阅读，发现发送事件通过<code>Kubelet.recorder</code>，该类实现了<code>record.EventRecorder</code>接口，接口具体定义在 <code>client-go/tools/record/event.go</code>中，主要定义了如下发送事件的几个方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// EventRecorder knows how to record events on behalf of an EventSource.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">EventRecorder</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#75715e">// The resulting event will be created in the same namespace as the reference object.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Event</span>(<span style="color:#a6e22e">object</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">message</span> <span style="color:#66d9ef">string</span>)

	<span style="color:#75715e">// Eventf is just like Event, but with Sprintf for the message field.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Eventf</span>(<span style="color:#a6e22e">object</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">messageFmt</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">args</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{})

	<span style="color:#75715e">// PastEventf is just like Eventf, but with an option to specify the event&#39;s &#39;timestamp&#39; field.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PastEventf</span>(<span style="color:#a6e22e">object</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">timestamp</span> <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">Time</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">messageFmt</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">args</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{})

	<span style="color:#75715e">// AnnotatedEventf is just like eventf, but with annotations attached
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">AnnotatedEventf</span>(<span style="color:#a6e22e">object</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">annotations</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">messageFmt</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">args</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{})
}</code></pre></div>
<h3 id="makeeventrecorder">makeEventRecorder</h3>

<p>recorder 的初始化过程调用了 makeEventRecorder 方法，<code>eventBroadcaster.NewRecorder</code>方法返回了一个<code>record.EventRecorder</code>接口的具体实现，并且指定的事件发送的来源，这里来源组件为 Kubelet。
可以看到此方法先 New 了一个 <code>record.EventBroadcaster</code>，再通过 eventBroadcaster 生成一个 <code>record.EventRecorder</code>，这里 NewRecorder 时指定了该 recorder 发送的 Event 事件中的来源，即 Component 和 Host，StartLogging 和 StartRecordingToSink 都是 eventBroadcaster 的方法，会调用 StartEventWatcher，接受发送过来的事件信息，并调用 eventHandler 方法对事件进行处理，具体过程下面会分析，这里 StartLogging 主要用于 klog 记录日志，StartRecordingToSink 会对事件进行聚合并存储。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// makeEventRecorder sets up kubeDeps.Recorder if it&#39;s nil. It&#39;s a no-op otherwise.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeEventRecorder</span>(<span style="color:#a6e22e">kubeDeps</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">kubelet</span>.<span style="color:#a6e22e">Dependencies</span>, <span style="color:#a6e22e">nodeName</span> <span style="color:#a6e22e">types</span>.<span style="color:#a6e22e">NodeName</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">kubeDeps</span>.<span style="color:#a6e22e">Recorder</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">eventBroadcaster</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">NewBroadcaster</span>()
	<span style="color:#a6e22e">kubeDeps</span>.<span style="color:#a6e22e">Recorder</span> = <span style="color:#a6e22e">eventBroadcaster</span>.<span style="color:#a6e22e">NewRecorder</span>(<span style="color:#a6e22e">legacyscheme</span>.<span style="color:#a6e22e">Scheme</span>, <span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">EventSource</span>{<span style="color:#a6e22e">Component</span>: <span style="color:#a6e22e">componentKubelet</span>, <span style="color:#a6e22e">Host</span>: string(<span style="color:#a6e22e">nodeName</span>)})
	<span style="color:#a6e22e">eventBroadcaster</span>.<span style="color:#a6e22e">StartLogging</span>(<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">3</span>).<span style="color:#a6e22e">Infof</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">kubeDeps</span>.<span style="color:#a6e22e">EventClient</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">4</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;Sending events to api server.&#34;</span>)
		<span style="color:#a6e22e">eventBroadcaster</span>.<span style="color:#a6e22e">StartRecordingToSink</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v1core</span>.<span style="color:#a6e22e">EventSinkImpl</span>{<span style="color:#a6e22e">Interface</span>: <span style="color:#a6e22e">kubeDeps</span>.<span style="color:#a6e22e">EventClient</span>.<span style="color:#a6e22e">Events</span>(<span style="color:#e6db74">&#34;&#34;</span>)})
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Warning</span>(<span style="color:#e6db74">&#34;No api server defined - no events will be sent to API server.&#34;</span>)
	}
}</code></pre></div>
<h3 id="recorder">recorder</h3>

<p><code>record.EventRecorder</code>接口的定义已经在上面贴出来了，这里看一下 kubelet 中使用的 recorder 的具体实现。上面说到 kubelet 调用 makeEventRecorder New 出了一个<code>record.EventRecorder</code>实例并赋值给了<code>kubeDeps.Recorder</code>，这就是 kubelet中使用的 recorder， 具体的实现为私有类<code>recorderImpl</code>，定义在<code>client-go/tools/record/event.go</code>。
私有方法 generateEvent 负责发送事件，执行 recorder.Action 将 event 加入 Broadcaster 的 incoming 队列，实现消息发送，这里 Action 是 recorder 结构体中包含的<code>*watch.Broadcaster</code>定义的方法， incoming 也是其中定义的一个带缓存的 channel。这个<code>*watch.Broadcaster</code>在下面的 EventBroadcaster 中还会提到，它是负责事件广播的组件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">recorderImpl</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">scheme</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Scheme</span>
	<span style="color:#a6e22e">source</span> <span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">EventSource</span>
	<span style="color:#f92672">*</span><span style="color:#a6e22e">watch</span>.<span style="color:#a6e22e">Broadcaster</span>
	<span style="color:#a6e22e">clock</span> <span style="color:#a6e22e">clock</span>.<span style="color:#a6e22e">Clock</span>
}

<span style="color:#75715e">// generateEvent 调用 recorder.Action 发送事件
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">recorder</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">recorderImpl</span>) <span style="color:#a6e22e">generateEvent</span>(<span style="color:#a6e22e">object</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">annotations</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">timestamp</span> <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">Time</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">message</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">ref</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ref</span>.<span style="color:#a6e22e">GetReference</span>(<span style="color:#a6e22e">recorder</span>.<span style="color:#a6e22e">scheme</span>, <span style="color:#a6e22e">object</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Could not construct reference to: &#39;%#v&#39; due to: &#39;%v&#39;. Will not report event: &#39;%v&#39; &#39;%v&#39; &#39;%v&#39;&#34;</span>, <span style="color:#a6e22e">object</span>, <span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">message</span>)
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">util</span>.<span style="color:#a6e22e">ValidateEventType</span>(<span style="color:#a6e22e">eventtype</span>) {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Unsupported event type: &#39;%v&#39;&#34;</span>, <span style="color:#a6e22e">eventtype</span>)
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">event</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">recorder</span>.<span style="color:#a6e22e">makeEvent</span>(<span style="color:#a6e22e">ref</span>, <span style="color:#a6e22e">annotations</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">message</span>)
	<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Source</span> = <span style="color:#a6e22e">recorder</span>.<span style="color:#a6e22e">source</span>

	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#75715e">// NOTE: events should be a non-blocking operation
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleCrash</span>()
		<span style="color:#a6e22e">recorder</span>.<span style="color:#a6e22e">Action</span>(<span style="color:#a6e22e">watch</span>.<span style="color:#a6e22e">Added</span>, <span style="color:#a6e22e">event</span>)
	}()
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">recorder</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">recorderImpl</span>) <span style="color:#a6e22e">Event</span>(<span style="color:#a6e22e">object</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">message</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">recorder</span>.<span style="color:#a6e22e">generateEvent</span>(<span style="color:#a6e22e">object</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">Now</span>(), <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">message</span>)
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">recorder</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">recorderImpl</span>) <span style="color:#a6e22e">Eventf</span>(<span style="color:#a6e22e">object</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">messageFmt</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">args</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">recorder</span>.<span style="color:#a6e22e">Event</span>(<span style="color:#a6e22e">object</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#a6e22e">messageFmt</span>, <span style="color:#a6e22e">args</span><span style="color:#f92672">...</span>))
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">recorder</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">recorderImpl</span>) <span style="color:#a6e22e">PastEventf</span>(<span style="color:#a6e22e">object</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">timestamp</span> <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">Time</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">messageFmt</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">args</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">recorder</span>.<span style="color:#a6e22e">generateEvent</span>(<span style="color:#a6e22e">object</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">timestamp</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#a6e22e">messageFmt</span>, <span style="color:#a6e22e">args</span><span style="color:#f92672">...</span>))
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">recorder</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">recorderImpl</span>) <span style="color:#a6e22e">AnnotatedEventf</span>(<span style="color:#a6e22e">object</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>, <span style="color:#a6e22e">annotations</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">messageFmt</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">args</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">recorder</span>.<span style="color:#a6e22e">generateEvent</span>(<span style="color:#a6e22e">object</span>, <span style="color:#a6e22e">annotations</span>, <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">Now</span>(), <span style="color:#a6e22e">eventtype</span>, <span style="color:#a6e22e">reason</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#a6e22e">messageFmt</span>, <span style="color:#a6e22e">args</span><span style="color:#f92672">...</span>))
}

<span style="color:#75715e">// ... ...
</span><span style="color:#75715e">// Action distributes the given event among all watchers.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Broadcaster</span>) <span style="color:#a6e22e">Action</span>(<span style="color:#a6e22e">action</span> <span style="color:#a6e22e">EventType</span>, <span style="color:#a6e22e">obj</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>) {
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">incoming</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">Event</span>{<span style="color:#a6e22e">action</span>, <span style="color:#a6e22e">obj</span>}
}</code></pre></div>
<h3 id="eventbroadcaster">EventBroadcaster</h3>

<p>eventBroadcasterImpl 是 <code>record.EventBroadcaster</code> 的具体实现，结构体定义如下，包含了一个<code>*watch.Broadcaster</code>，kubelet 中 makeEventRecorder 中调用了 <code>eventBroadcaster.StartRecordingToSink</code> 方法，该方法又调用了 StartEventWatcher，进行 event 监听。<br />
<em>event aggregator</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">eventBroadcasterImpl</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#f92672">*</span><span style="color:#a6e22e">watch</span>.<span style="color:#a6e22e">Broadcaster</span>
	<span style="color:#a6e22e">sleepDuration</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
	<span style="color:#a6e22e">options</span>       <span style="color:#a6e22e">CorrelatorOptions</span>
}

<span style="color:#75715e">// StartRecordingToSink starts sending events received from the specified eventBroadcaster to the given sink.
</span><span style="color:#75715e">// The return value can be ignored or used to stop recording, if desired.
</span><span style="color:#75715e">// TODO: make me an object with parameterizable queue length and retry interval
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">eventBroadcasterImpl</span>) <span style="color:#a6e22e">StartRecordingToSink</span>(<span style="color:#a6e22e">sink</span> <span style="color:#a6e22e">EventSink</span>) <span style="color:#a6e22e">watch</span>.<span style="color:#a6e22e">Interface</span> {
	<span style="color:#a6e22e">eventCorrelator</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewEventCorrelatorWithOptions</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">options</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">StartEventWatcher</span>(
		<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) {
			<span style="color:#a6e22e">recordToSink</span>(<span style="color:#a6e22e">sink</span>, <span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">eventCorrelator</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">sleepDuration</span>)
		})
}

<span style="color:#75715e">// StartEventWatcher starts sending events received from this EventBroadcaster to the given event handler function.
</span><span style="color:#75715e">// The return value can be ignored or used to stop recording, if desired.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">eventBroadcasterImpl</span>) <span style="color:#a6e22e">StartEventWatcher</span>(<span style="color:#a6e22e">eventHandler</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>)) <span style="color:#a6e22e">watch</span>.<span style="color:#a6e22e">Interface</span> {
	<span style="color:#a6e22e">watcher</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Watch</span>()
	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleCrash</span>()
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">watchEvent</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">watcher</span>.<span style="color:#a6e22e">ResultChan</span>() {
			<span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">watchEvent</span>.<span style="color:#a6e22e">Object</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>)
			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
				<span style="color:#75715e">// This is all local, so there&#39;s no reason this should
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// ever happen.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">continue</span>
			}
			<span style="color:#a6e22e">eventHandler</span>(<span style="color:#a6e22e">event</span>)
		}
	}()
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">watcher</span>
}</code></pre></div>
<h3 id="watch-broadcaster">watch.Broadcaster</h3>

<p>根据上面的分析，recorder 通过调用<code>*watch.Broadcaster</code>的 Action 方法将 event 发送到 Broadcaster 的 incoming 队列完成发送，EventBroadcaster 的 StartRecordingToSink 方法，最终调用到了<code>*watch.Broadcaster</code>的 Watch 方法，对事件进行监听。可以看到在事件的传递中，<code>*watch.Broadcaster</code>是一个非常重要的部分，根据命名可以猜到，它的作用就是对事件进行广播。那么 <code>*watch.Broadcaster</code> 是如何接收 recorder 发送的事件并广播给所有的 watcher 呢？<br />
<code>*watch.Broadcaster</code>定义在<code>apimachinery/pkg/watch/mux.go</code>。下面贴出了结构体定义和初始化的方法。<br />
可以看到 incoming 队列是通过 <code>make(chan Event, incomingQueueLength)</code> 初始化，这是一个带缓存的通道，缓存大小为 incomingQueueLength，值固定为25。对 incomingQueueLength 的定义，代码里解释为*通常情况下传入的队列很少会阻塞，这里加上缓冲，是为了防止万一在一个很短的窗口内接收到事件导致Broadcaster无法及时处理*。还有一个重要的 map 类型 <code>watchers</code>，它用来存储已经注册进来的 watcher，当 incoming 队列中收到消息，会对 watchers 中所有的 broadcasterWatcher 进行广播，int64 类型的<code>nextWatcher</code>作为 map 中 watcher 的 key，每新增一个 watcher，nextWatcher 自增加一，并作为新增 watcher 的 id，同时可以看到为了防止并发产生异常，watcher 相关的操作都做了加锁操作，这就是<code>*watch.Broadcaster</code>广播的基本原理。具体的实现可以看下 Watch 方法的逻辑，EventBroadcaster 最终调用到 Watch 方法，Watch 方法创建一个 broadcasterWatcher 加入 watchers，并返回给调用方，调用方拿到 watcher 调用 <code>watcher.ResultChan()</code> 监听事件。<br />
到这里事件如何通过 Broadcaster 进行发送和监听就已经比较清晰了，还有一个问题，就是 Broadcaster 进行广播的动作，是在何时开始的呢？其实在 NewBroadcaster() 的时候，已经在最后执行了<code>go m.loop()</code>，loop() 方法中做的事情，就是从 incoming 队列中取出队列，并推送给所有的 watcher，代码也贴出在下面，可以自己看下方法中的具体逻辑。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// Broadcaster distributes event notifications among any number of watchers. Every event
</span><span style="color:#75715e">// is delivered to every watcher.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Broadcaster</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#75715e">// TODO: see if this lock is needed now that new watchers go through
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// the incoming channel.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>

	<span style="color:#a6e22e">watchers</span>     <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int64</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">broadcasterWatcher</span>
	<span style="color:#a6e22e">nextWatcher</span>  <span style="color:#66d9ef">int64</span>
	<span style="color:#a6e22e">distributing</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

	<span style="color:#a6e22e">incoming</span> <span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Event</span>

	<span style="color:#75715e">// How large to make watcher&#39;s channel.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">watchQueueLength</span> <span style="color:#66d9ef">int</span>
	<span style="color:#75715e">// If one of the watch channels is full, don&#39;t wait for it to become empty.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// Instead just deliver it to the watchers that do have space in their
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// channels and move on to the next event.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// It&#39;s more fair to do this on a per-watcher basis than to do it on the
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// &#34;incoming&#34; channel, which would allow one slow watcher to prevent all
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// other watchers from getting new events.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fullChannelBehavior</span> <span style="color:#a6e22e">FullChannelBehavior</span>
}
<span style="color:#75715e">// NewBroadcaster creates a new Broadcaster. queueLength is the maximum number of events to queue per watcher.
</span><span style="color:#75715e">// It is guaranteed that events will be distributed in the order in which they occur,
</span><span style="color:#75715e">// but the order in which a single event is distributed among all of the watchers is unspecified.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewBroadcaster</span>(<span style="color:#a6e22e">queueLength</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">fullChannelBehavior</span> <span style="color:#a6e22e">FullChannelBehavior</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Broadcaster</span> {
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Broadcaster</span>{
		<span style="color:#a6e22e">watchers</span>:            <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int64</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">broadcasterWatcher</span>{},
		<span style="color:#a6e22e">incoming</span>:            make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">incomingQueueLength</span>),
		<span style="color:#a6e22e">watchQueueLength</span>:    <span style="color:#a6e22e">queueLength</span>,
		<span style="color:#a6e22e">fullChannelBehavior</span>: <span style="color:#a6e22e">fullChannelBehavior</span>,
	}
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">distributing</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">loop</span>()
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>
}

<span style="color:#75715e">// Action distributes the given event among all watchers.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Broadcaster</span>) <span style="color:#a6e22e">Action</span>(<span style="color:#a6e22e">action</span> <span style="color:#a6e22e">EventType</span>, <span style="color:#a6e22e">obj</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Object</span>) {
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">incoming</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">Event</span>{<span style="color:#a6e22e">action</span>, <span style="color:#a6e22e">obj</span>}
}

<span style="color:#75715e">// watcher 的注册和维护
</span><span style="color:#75715e">// Watch adds a new watcher to the list and returns an Interface for it.
</span><span style="color:#75715e">// Note: new watchers will only receive new events. They won&#39;t get an entire history
</span><span style="color:#75715e">// of previous events.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Broadcaster</span>) <span style="color:#a6e22e">Watch</span>() <span style="color:#a6e22e">Interface</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">broadcasterWatcher</span>
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">blockQueue</span>(<span style="color:#66d9ef">func</span>() {
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>()
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>()
		<span style="color:#a6e22e">id</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">nextWatcher</span>
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">nextWatcher</span><span style="color:#f92672">++</span>
		<span style="color:#a6e22e">w</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">broadcasterWatcher</span>{
			<span style="color:#a6e22e">result</span>:  make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">watchQueueLength</span>),
			<span style="color:#a6e22e">stopped</span>: make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}),
			<span style="color:#a6e22e">id</span>:      <span style="color:#a6e22e">id</span>,
			<span style="color:#a6e22e">m</span>:       <span style="color:#a6e22e">m</span>,
		}
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">watchers</span>[<span style="color:#a6e22e">id</span>] = <span style="color:#a6e22e">w</span>
	})
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">w</span>
}
<span style="color:#75715e">// Execute f, blocking the incoming queue (and waiting for it to drain first).
</span><span style="color:#75715e">// The purpose of this terrible hack is so that watchers added after an event
</span><span style="color:#75715e">// won&#39;t ever see that event, and will always see any event after they are
</span><span style="color:#75715e">// added.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Broadcaster</span>) <span style="color:#a6e22e">blockQueue</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>()) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">incoming</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">Event</span>{
		<span style="color:#a6e22e">Type</span>: <span style="color:#a6e22e">internalRunFunctionMarker</span>,
		<span style="color:#a6e22e">Object</span>: <span style="color:#a6e22e">functionFakeRuntimeObject</span>(<span style="color:#66d9ef">func</span>() {
			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
			<span style="color:#a6e22e">f</span>()
		}),
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}

<span style="color:#75715e">// 事件的广播
</span><span style="color:#75715e">// loop receives from m.incoming and distributes to all watchers.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Broadcaster</span>) <span style="color:#a6e22e">loop</span>() {
	<span style="color:#75715e">// Deliberately not catching crashes here. Yes, bring down the process if there&#39;s a
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// bug in watch.Broadcaster.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">event</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">incoming</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Type</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">internalRunFunctionMarker</span> {
			<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Object</span>.(<span style="color:#a6e22e">functionFakeRuntimeObject</span>)()
			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">distribute</span>(<span style="color:#a6e22e">event</span>)
	}
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">closeAll</span>()
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">distributing</span>.<span style="color:#a6e22e">Done</span>()
}
<span style="color:#75715e">// distribute sends event to all watchers. Blocking.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Broadcaster</span>) <span style="color:#a6e22e">distribute</span>(<span style="color:#a6e22e">event</span> <span style="color:#a6e22e">Event</span>) {
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">fullChannelBehavior</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">DropIfChannelFull</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">watchers</span> {
			<span style="color:#66d9ef">select</span> {
			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">result</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">event</span>:
			<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">stopped</span>:
			<span style="color:#66d9ef">default</span>: <span style="color:#75715e">// Don&#39;t block if the event can&#39;t be queued.
</span><span style="color:#75715e"></span>			}
		}
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">watchers</span> {
			<span style="color:#66d9ef">select</span> {
			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">result</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">event</span>:
			<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">stopped</span>:
			}
		}
	}
}</code></pre></div>
<h3 id="eventsink">EventSink</h3>

<p>分析完一个事件在 kubernetes 中的发送和接收流程，还有最后一个问题，event 最终是如何存储到 ETCD 中，以什么形式存储到 ETCD 中的呢？再深一层追踪代码，可以发现一个 EventSink 的 interface，这个就是 kubernetes 提供的存储 Event 的接口，定义如下。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// EventSink knows how to store events (client.Client implements it.)
</span><span style="color:#75715e">// EventSink must respect the namespace that will be embedded in &#39;event&#39;.
</span><span style="color:#75715e">// It is assumed that EventSink will return the same sorts of errors as
</span><span style="color:#75715e">// pkg/client&#39;s REST client.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">EventSink</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">Create</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#66d9ef">error</span>)
	<span style="color:#a6e22e">Update</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#66d9ef">error</span>)
	<span style="color:#a6e22e">Patch</span>(<span style="color:#a6e22e">oldEvent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">data</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#66d9ef">error</span>)
}</code></pre></div>
<p><code>record.EventBroadcaster</code>的<code>StartRecordingToSink(sink EventSink) watch.Interface{}</code>方法，接收一个 EventSink 类型作为参数，这里回到 kubelet，看到 kubelet 初始化时在 makeEventRecorder 方法中调用这样调用<code>eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl{Interface: kubeDeps.EventClient.Events(&quot;&quot;)})</code>，
传入的 EventSinkImpl，kubernetes 1.17 版本中结构体定义的注释中写了 TODO，后面要将所有 client 都移到 clientset 中。再往深层追踪，传入的<code>kubeDeps.EventClient.Events(&quot;&quot;)</code>，<code>kubeDeps.EventClient</code>初始化方法为<code>kubeDeps.EventClient, err = v1core.NewForConfig(&amp;eventClientConfig)</code>，熟悉 kubernetes sdk 的可以看出来，这里创建的<code>corev1.CoreV1Client</code>，就是 clientset 中的客户端，
CoreV1Client.Event(&ldquo;&rdquo;) 返回的就是针对 Event 这一资源操作的 REST Client，封装了对 Event 增删改查的操作。由此可以看出，EventSink 其实就是连接 recorder 和底层存储的中间层，所以存入 ETCD 的操作，自然是 EventSink 来执行，甚至，如果你想将 kubernetes 的 event 存入其他数据库，只要封装一个对应的客户端，并实现 EventSink 的方法，就可以做到。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// TODO: This is a temporary arrangement and will be removed once all clients are moved to use the clientset.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">EventSinkImpl</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Interface</span> <span style="color:#a6e22e">EventInterface</span>
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventSinkImpl</span>) <span style="color:#a6e22e">Create</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Interface</span>.<span style="color:#a6e22e">CreateWithEventNamespace</span>(<span style="color:#a6e22e">event</span>)
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventSinkImpl</span>) <span style="color:#a6e22e">Update</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Interface</span>.<span style="color:#a6e22e">UpdateWithEventNamespace</span>(<span style="color:#a6e22e">event</span>)
}
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventSinkImpl</span>) <span style="color:#a6e22e">Patch</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">data</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Interface</span>.<span style="color:#a6e22e">PatchWithEventNamespace</span>(<span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">data</span>)
}</code></pre></div>
<h3 id="eventcorrelator">EventCorrelator</h3>

<p>此时再回头看一下 StartRecordingToSink 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// StartRecordingToSink starts sending events received from the specified eventBroadcaster to the given sink.
</span><span style="color:#75715e">// The return value can be ignored or used to stop recording, if desired.
</span><span style="color:#75715e">// TODO: make me an object with parameterizable queue length and retry interval
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">eventBroadcasterImpl</span>) <span style="color:#a6e22e">StartRecordingToSink</span>(<span style="color:#a6e22e">sink</span> <span style="color:#a6e22e">EventSink</span>) <span style="color:#a6e22e">watch</span>.<span style="color:#a6e22e">Interface</span> {
	<span style="color:#a6e22e">eventCorrelator</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewEventCorrelatorWithOptions</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">options</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">StartEventWatcher</span>(
		<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) {
			<span style="color:#a6e22e">recordToSink</span>(<span style="color:#a6e22e">sink</span>, <span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">eventCorrelator</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">sleepDuration</span>)
		})
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">recordToSink</span>(<span style="color:#a6e22e">sink</span> <span style="color:#a6e22e">EventSink</span>, <span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">eventCorrelator</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventCorrelator</span>, <span style="color:#a6e22e">sleepDuration</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) {
	<span style="color:#75715e">// Make a copy before modification, because there could be multiple listeners.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// Events are safe to copy like this.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">eventCopy</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">event</span>
	<span style="color:#a6e22e">event</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">eventCopy</span>
	<span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">eventCorrelator</span>.<span style="color:#a6e22e">EventCorrelate</span>(<span style="color:#a6e22e">event</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">utilruntime</span>.<span style="color:#a6e22e">HandleError</span>(<span style="color:#a6e22e">err</span>)
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Skip</span> {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#a6e22e">tries</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">recordEvent</span>(<span style="color:#a6e22e">sink</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Patch</span>, <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">Event</span>.<span style="color:#a6e22e">Count</span> &gt; <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">eventCorrelator</span>) {
			<span style="color:#66d9ef">break</span>
		}
		<span style="color:#a6e22e">tries</span><span style="color:#f92672">++</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tries</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">maxTriesPerEvent</span> {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Unable to write event &#39;%#v&#39; (retry limit exceeded!)&#34;</span>, <span style="color:#a6e22e">event</span>)
			<span style="color:#66d9ef">break</span>
		}
		<span style="color:#75715e">// Randomize the first sleep so that various clients won&#39;t all be
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// synced up if the master goes down.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tries</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
			<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>(float64(<span style="color:#a6e22e">sleepDuration</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Float64</span>()))
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">sleepDuration</span>)
		}
	}
}

<span style="color:#75715e">// recordEvent attempts to write event to a sink. It returns true if the event
</span><span style="color:#75715e">// was successfully recorded or discarded, false if it should be retried.
</span><span style="color:#75715e">// If updateExistingEvent is false, it creates a new event, otherwise it updates
</span><span style="color:#75715e">// existing event.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">recordEvent</span>(<span style="color:#a6e22e">sink</span> <span style="color:#a6e22e">EventSink</span>, <span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">patch</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">updateExistingEvent</span> <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">eventCorrelator</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventCorrelator</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">newEvent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">updateExistingEvent</span> {
		<span style="color:#a6e22e">newEvent</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">sink</span>.<span style="color:#a6e22e">Patch</span>(<span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">patch</span>)
	}
	<span style="color:#75715e">// Update can fail because the event may have been removed and it no longer exists.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">updateExistingEvent</span> <span style="color:#f92672">||</span> (<span style="color:#a6e22e">updateExistingEvent</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">util</span>.<span style="color:#a6e22e">IsKeyNotFoundError</span>(<span style="color:#a6e22e">err</span>)) {
		<span style="color:#75715e">// Making sure that ResourceVersion is empty on creation
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">ResourceVersion</span> = <span style="color:#e6db74">&#34;&#34;</span>
		<span style="color:#a6e22e">newEvent</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">sink</span>.<span style="color:#a6e22e">Create</span>(<span style="color:#a6e22e">event</span>)
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#75715e">// we need to update our event correlator with the server returned state to handle name/resourceversion
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">eventCorrelator</span>.<span style="color:#a6e22e">UpdateState</span>(<span style="color:#a6e22e">newEvent</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}

	<span style="color:#75715e">// If we can&#39;t contact the server, then hold everything while we keep trying.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// Otherwise, something about the event is malformed and we should abandon it.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">err</span>.(<span style="color:#66d9ef">type</span>) {
	<span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">restclient</span>.<span style="color:#a6e22e">RequestConstructionError</span>:
		<span style="color:#75715e">// We will construct the request the same next time, so don&#39;t keep trying.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Unable to construct event &#39;%#v&#39;: &#39;%v&#39; (will not retry!)&#34;</span>, <span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">err</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	<span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">StatusError</span>:
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">IsAlreadyExists</span>(<span style="color:#a6e22e">err</span>) {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">5</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;Server rejected event &#39;%#v&#39;: &#39;%v&#39; (will not retry!)&#34;</span>, <span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">err</span>)
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Server rejected event &#39;%#v&#39;: &#39;%v&#39; (will not retry!)&#34;</span>, <span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">err</span>)
		}
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	<span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">UnexpectedObjectError</span>:
		<span style="color:#75715e">// We don&#39;t expect this; it implies the server&#39;s response didn&#39;t match a
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// known pattern. Go ahead and retry.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">default</span>:
		<span style="color:#75715e">// This case includes actual http transport errors. Go ahead and retry.
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Unable to write event: &#39;%v&#39; (may retry after sleeping)&#34;</span>, <span style="color:#a6e22e">err</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
}</code></pre></div>
<h4 id="neweventcorrelator">NewEventCorrelator</h4>

<p>在 StartEventWatcher 中传入的处理方法为 recordToSink，也就是说，当 watcher 接收到一个事件，会通过调用 recordToSink 进行处理。这里有一个新的结构体 EventCorrelator，顾名思义，它负责事件记录时的关联，作用主要是事件的过滤、聚合和计数。它有一个关键成员 aggregator，它用来对传入的事件进行聚合。关于 EventCorrelator 关联事件的具体规则，可以通过 populateDefaults 方法看到它的默认参数配置。具体每个参数的作用，后面再具体分析。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// EventCorrelator 初始化
</span><span style="color:#75715e">// EventCorrelator processes all incoming events and performs analysis to avoid overwhelming the system.  It can filter all
</span><span style="color:#75715e">// incoming events to see if the event should be filtered from further processing.  It can aggregate similar events that occur
</span><span style="color:#75715e">// frequently to protect the system from spamming events that are difficult for users to distinguish.  It performs de-duplication
</span><span style="color:#75715e">// to ensure events that are observed multiple times are compacted into a single event with increasing counts.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">EventCorrelator</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#75715e">// the function to filter the event
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">filterFunc</span> <span style="color:#a6e22e">EventFilterFunc</span>
	<span style="color:#75715e">// the object that performs event aggregation
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">aggregator</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventAggregator</span>
	<span style="color:#75715e">// the object that observes events as they come through
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">logger</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">eventLogger</span>
}
<span style="color:#75715e">// EventAggregator identifies similar events and aggregates them into a single event
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">EventAggregator</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>

	<span style="color:#75715e">// The cache that manages aggregation state
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cache</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">Cache</span>

	<span style="color:#75715e">// The function that groups events for aggregation
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">keyFunc</span> <span style="color:#a6e22e">EventAggregatorKeyFunc</span>

	<span style="color:#75715e">// The function that generates a message for an aggregate event
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">messageFunc</span> <span style="color:#a6e22e">EventAggregatorMessageFunc</span>

	<span style="color:#75715e">// The maximum number of events in the specified interval before aggregation occurs
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">maxEvents</span> <span style="color:#66d9ef">uint</span>

	<span style="color:#75715e">// The amount of time in seconds that must transpire since the last occurrence of a similar event before it&#39;s considered new
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">maxIntervalInSeconds</span> <span style="color:#66d9ef">uint</span>

	<span style="color:#75715e">// clock is used to allow for testing over a time interval
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">clock</span> <span style="color:#a6e22e">clock</span>.<span style="color:#a6e22e">Clock</span>
}

<span style="color:#75715e">// EventAggregatorByReasonFunc aggregates events by exact match on event.Source, event.InvolvedObject, event.Type and event.Reason
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">EventAggregatorByReasonFunc</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">string</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>([]<span style="color:#66d9ef">string</span>{
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Source</span>.<span style="color:#a6e22e">Component</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Source</span>.<span style="color:#a6e22e">Host</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Kind</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Namespace</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Name</span>,
		string(<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">UID</span>),
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">APIVersion</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Type</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Reason</span>,
	},
		<span style="color:#e6db74">&#34;&#34;</span>), <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Message</span>
}
<span style="color:#75715e">// EventAggregratorByReasonMessageFunc returns an aggregate message by prefixing the incoming message
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">EventAggregatorByReasonMessageFunc</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) <span style="color:#66d9ef">string</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;(combined from similar events): &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Message</span>
}

<span style="color:#75715e">// NewEventCorrelator returns an EventCorrelator configured with default values.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// The EventCorrelator is responsible for event filtering, aggregating, and counting
</span><span style="color:#75715e">// prior to interacting with the API server to record the event.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// The default behavior is as follows:
</span><span style="color:#75715e">//   * Aggregation is performed if a similar event is recorded 10 times in a
</span><span style="color:#75715e">//     in a 10 minute rolling interval.  A similar event is an event that varies only by
</span><span style="color:#75715e">//     the Event.Message field.  Rather than recording the precise event, aggregation
</span><span style="color:#75715e">//     will create a new event whose message reports that it has combined events with
</span><span style="color:#75715e">//     the same reason.
</span><span style="color:#75715e">//   * Events are incrementally counted if the exact same event is encountered multiple
</span><span style="color:#75715e">//     times.
</span><span style="color:#75715e">//   * A source may burst 25 events about an object, but has a refill rate budget
</span><span style="color:#75715e">//     per object of 1 event every 5 minutes to control long-tail of spam.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewEventCorrelator</span>(<span style="color:#a6e22e">clock</span> <span style="color:#a6e22e">clock</span>.<span style="color:#a6e22e">Clock</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">EventCorrelator</span> {
	<span style="color:#a6e22e">cacheSize</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">maxLruCacheEntries</span>
	<span style="color:#a6e22e">spamFilter</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewEventSourceObjectSpamFilter</span>(<span style="color:#a6e22e">cacheSize</span>, <span style="color:#a6e22e">defaultSpamBurst</span>, <span style="color:#a6e22e">defaultSpamQPS</span>, <span style="color:#a6e22e">clock</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">EventCorrelator</span>{
		<span style="color:#a6e22e">filterFunc</span>: <span style="color:#a6e22e">spamFilter</span>.<span style="color:#a6e22e">Filter</span>,
		<span style="color:#a6e22e">aggregator</span>: <span style="color:#a6e22e">NewEventAggregator</span>(
			<span style="color:#a6e22e">cacheSize</span>,
			<span style="color:#a6e22e">EventAggregatorByReasonFunc</span>,
			<span style="color:#a6e22e">EventAggregatorByReasonMessageFunc</span>,
			<span style="color:#a6e22e">defaultAggregateMaxEvents</span>,
			<span style="color:#a6e22e">defaultAggregateIntervalInSeconds</span>,
			<span style="color:#a6e22e">clock</span>),

		<span style="color:#a6e22e">logger</span>: <span style="color:#a6e22e">newEventLogger</span>(<span style="color:#a6e22e">cacheSize</span>, <span style="color:#a6e22e">clock</span>),
	}
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewEventCorrelatorWithOptions</span>(<span style="color:#a6e22e">options</span> <span style="color:#a6e22e">CorrelatorOptions</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">EventCorrelator</span> {
	<span style="color:#a6e22e">optionsWithDefaults</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">populateDefaults</span>(<span style="color:#a6e22e">options</span>)
	<span style="color:#a6e22e">spamFilter</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewEventSourceObjectSpamFilter</span>(<span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">LRUCacheSize</span>,
		<span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">BurstSize</span>, <span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">QPS</span>, <span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">Clock</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">EventCorrelator</span>{
		<span style="color:#a6e22e">filterFunc</span>: <span style="color:#a6e22e">spamFilter</span>.<span style="color:#a6e22e">Filter</span>,
		<span style="color:#a6e22e">aggregator</span>: <span style="color:#a6e22e">NewEventAggregator</span>(
			<span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">LRUCacheSize</span>,
			<span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">KeyFunc</span>,
			<span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">MessageFunc</span>,
			<span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">MaxEvents</span>,
			<span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">MaxIntervalInSeconds</span>,
			<span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">Clock</span>),
		<span style="color:#a6e22e">logger</span>: <span style="color:#a6e22e">newEventLogger</span>(<span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">LRUCacheSize</span>, <span style="color:#a6e22e">optionsWithDefaults</span>.<span style="color:#a6e22e">Clock</span>),
	}
}
<span style="color:#75715e">// populateDefaults populates the zero value options with defaults
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">populateDefaults</span>(<span style="color:#a6e22e">options</span> <span style="color:#a6e22e">CorrelatorOptions</span>) <span style="color:#a6e22e">CorrelatorOptions</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">LRUCacheSize</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#75715e">// maxLruCacheEntries = 4096
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">LRUCacheSize</span> = <span style="color:#a6e22e">maxLruCacheEntries</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">BurstSize</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#75715e">// by default, allow a source to send 25 events about an object
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// but control the refill rate to 1 new event every 5 minutes
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// this helps control the long-tail of events for things that are always
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// unhealthy. defaultSpamBurst = 25
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// defaultSpamQPS   = 1. / 300.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">BurstSize</span> = <span style="color:#a6e22e">defaultSpamBurst</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">QPS</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">QPS</span> = <span style="color:#a6e22e">defaultSpamQPS</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">KeyFunc</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">KeyFunc</span> = <span style="color:#a6e22e">EventAggregatorByReasonFunc</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">MessageFunc</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">MessageFunc</span> = <span style="color:#a6e22e">EventAggregatorByReasonMessageFunc</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">MaxEvents</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#75715e">// if we see the same event that varies only by message
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// more than 10 times in a 10 minute period, aggregate the event.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// defaultAggregateMaxEvents         = 10
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// defaultAggregateIntervalInSeconds = 600
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">MaxEvents</span> = <span style="color:#a6e22e">defaultAggregateMaxEvents</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">MaxIntervalInSeconds</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">MaxIntervalInSeconds</span> = <span style="color:#a6e22e">defaultAggregateIntervalInSeconds</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">Clock</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">Clock</span> = <span style="color:#a6e22e">clock</span>.<span style="color:#a6e22e">RealClock</span>{}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">options</span>
}</code></pre></div>
<h4 id="eventcorrelate">EventCorrelate</h4>

<p>EventCorrelator 的关键方法是 EventCorrelate，它接收一个新的 Event 事件，并返回一个 EventCorrelateResult，代表关联后的结果。EventCorrelate 中首先执行了<code>c.aggregator.EventAggregate(newEvent)</code>方法进行事件聚合，它根据上面初始化 EventCorrelator 时的配置，检查是否已经有和传入的事件类似的事件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// EventCorrelateResult is the result of a Correlate
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">EventCorrelateResult</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#75715e">// the event after correlation
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>
	<span style="color:#75715e">// if provided, perform a strategic patch when updating the record on the server
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Patch</span> []<span style="color:#66d9ef">byte</span>
	<span style="color:#75715e">// if true, do no further processing of the event
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Skip</span> <span style="color:#66d9ef">bool</span>
}
<span style="color:#75715e">// aggregateRecord holds data used to perform aggregation decisions
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">aggregateRecord</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#75715e">// we track the number of unique local keys we have seen in the aggregate set to know when to actually aggregate
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// if the size of this set exceeds the max, we know we need to aggregate
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">localKeys</span> <span style="color:#a6e22e">sets</span>.<span style="color:#a6e22e">String</span>
	<span style="color:#75715e">// The last time at which the aggregate was recorded
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lastTimestamp</span> <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">Time</span>
}

<span style="color:#75715e">// EventCorrelate filters, aggregates, counts, and de-duplicates all incoming events
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventCorrelator</span>) <span style="color:#a6e22e">EventCorrelate</span>(<span style="color:#a6e22e">newEvent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">EventCorrelateResult</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newEvent</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;event is nil&#34;</span>)
	}
	<span style="color:#a6e22e">aggregateEvent</span>, <span style="color:#a6e22e">ckey</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">aggregator</span>.<span style="color:#a6e22e">EventAggregate</span>(<span style="color:#a6e22e">newEvent</span>)
	<span style="color:#a6e22e">observedEvent</span>, <span style="color:#a6e22e">patch</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">logger</span>.<span style="color:#a6e22e">eventObserve</span>(<span style="color:#a6e22e">aggregateEvent</span>, <span style="color:#a6e22e">ckey</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">filterFunc</span>(<span style="color:#a6e22e">observedEvent</span>) {
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">EventCorrelateResult</span>{<span style="color:#a6e22e">Skip</span>: <span style="color:#66d9ef">true</span>}, <span style="color:#66d9ef">nil</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">EventCorrelateResult</span>{<span style="color:#a6e22e">Event</span>: <span style="color:#a6e22e">observedEvent</span>, <span style="color:#a6e22e">Patch</span>: <span style="color:#a6e22e">patch</span>}, <span style="color:#a6e22e">err</span>
}</code></pre></div>
<p>这里具体梳理一下 EventAggregate 方法的流程。<br />
1. 首先，基于 event 事件的属性构建 key。<br />
    通过 getEventKey 方法基于 Event 的<code>的source</code>, <code>involvedObject</code>, <code>reason</code>, <code>message</code>的值构建一个该事件的唯一 key 作为 eventKey，然后通过<code>EventAggregator.keyFunc</code>生成aggregateKey 和 localKey，这里的 keyfunc 就是 NewEventCorrelator 传入的 keyFunc，即 EventAggregatorByReasonFunc，它基于 Event 的<code>event.Source</code>, <code>event.InvolvedObject</code>, <code>event.Type</code> 和 <code>event.Reason</code>的值构建 key，返回的 key 作为 aggregateKey，event.Message 作为 localKey。<br />
2. 接着，通过 aggregateKey 从 cache 中获取缓存的 record ，或新建一个 record。<br />
    e.cache 是一个 LRU 缓存，这里存储的值的类型是 aggregateRecord，取出值后，若该记录的时间即 aggregateRecord.lastTimestamp 距当前超过了 maxIntervalInSeconds（默认600s），那么该缓存无效。若缓存无效或缓存未空，则新建一个新的 record。<br />
3. 将第一步构建出的 localKey 加入 上一步得到的 record 的 localKeys，并更新缓存。这里 localKeys 为字符串集合，localKey即为 event.message，所以 c.cache 中实际上保存了同一 aggregateKey 下的事件的 message。<br />
4. 返回 event 和 cache key。<br />
    若当前 record 的<code>record.localKeys</code>的长度小于 maxEvents（默认10），即同一 aggregateKey 下的 localKeys 数量没达到最大阈值，这代表以 event.reason 维度做聚合产生的事件数没达到需要做关联聚合的阈值，那么此时不需对该事件进行聚合，直接返回传入的 event 不做需改，并直接以 eventKey 作为 cache key 返回，可以回顾一下第一步中生成 eventKey 的方法，是以完整的 reason 和 message 拼接成的 key。
    否则的话，当<code>record.localKeys</code>长度大于maxEvents，说明此时在一段时间内同一 reason 产生的事件较多，这时会先从 localKeys 中删除最老的值（PopAny）以保证长度不会大于maxEvents，并对事件进行聚合，组装一个新的事件返回，并以 aggregateKey 作为 cache key 返回。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// EventAggregate checks if a similar event has been seen according to the
</span><span style="color:#75715e">// aggregation configuration (max events, max interval, etc) and returns:
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// - The (potentially modified) event that should be created
</span><span style="color:#75715e">// - The cache key for the event, for correlation purposes. This will be set to
</span><span style="color:#75715e">//   the full key for normal events, and to the result of
</span><span style="color:#75715e">//   EventAggregatorMessageFunc for aggregate events.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventAggregator</span>) <span style="color:#a6e22e">EventAggregate</span>(<span style="color:#a6e22e">newEvent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">now</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">NewTime</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">clock</span>.<span style="color:#a6e22e">Now</span>())
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">record</span> <span style="color:#a6e22e">aggregateRecord</span>
	<span style="color:#75715e">// eventKey is the full cache key for this event
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">eventKey</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getEventKey</span>(<span style="color:#a6e22e">newEvent</span>)
	<span style="color:#75715e">// aggregateKey is for the aggregate event, if one is needed.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">aggregateKey</span>, <span style="color:#a6e22e">localKey</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">keyFunc</span>(<span style="color:#a6e22e">newEvent</span>)

	<span style="color:#75715e">// Do we have a record of similar events in our cache?
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">found</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">aggregateKey</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">found</span> {
		<span style="color:#a6e22e">record</span> = <span style="color:#a6e22e">value</span>.(<span style="color:#a6e22e">aggregateRecord</span>)
	}

	<span style="color:#75715e">// Is the previous record too old? If so, make a fresh one. Note: if we didn&#39;t
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// find a similar record, its lastTimestamp will be the zero value, so we
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// create a new one in that case.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">maxInterval</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">maxIntervalInSeconds</span>) <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>
	<span style="color:#a6e22e">interval</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">now</span>.<span style="color:#a6e22e">Time</span>.<span style="color:#a6e22e">Sub</span>(<span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">lastTimestamp</span>.<span style="color:#a6e22e">Time</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">interval</span> &gt; <span style="color:#a6e22e">maxInterval</span> {
		<span style="color:#a6e22e">record</span> = <span style="color:#a6e22e">aggregateRecord</span>{<span style="color:#a6e22e">localKeys</span>: <span style="color:#a6e22e">sets</span>.<span style="color:#a6e22e">NewString</span>()}
	}

	<span style="color:#75715e">// Write the new event into the aggregation record and put it on the cache
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">localKeys</span>.<span style="color:#a6e22e">Insert</span>(<span style="color:#a6e22e">localKey</span>)
	<span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">lastTimestamp</span> = <span style="color:#a6e22e">now</span>
	<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">aggregateKey</span>, <span style="color:#a6e22e">record</span>)

	<span style="color:#75715e">// If we are not yet over the threshold for unique events, don&#39;t correlate them
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> uint(<span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">localKeys</span>.<span style="color:#a6e22e">Len</span>()) &lt; <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">maxEvents</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">newEvent</span>, <span style="color:#a6e22e">eventKey</span>
	}

	<span style="color:#75715e">// do not grow our local key set any larger than max
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">localKeys</span>.<span style="color:#a6e22e">PopAny</span>()

	<span style="color:#75715e">// create a new aggregate event, and return the aggregateKey as the cache key
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// (so that it can be overwritten.)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">eventCopy</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>{
		<span style="color:#a6e22e">ObjectMeta</span>: <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">ObjectMeta</span>{
			<span style="color:#a6e22e">Name</span>:      <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%v.%x&#34;</span>, <span style="color:#a6e22e">newEvent</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">now</span>.<span style="color:#a6e22e">UnixNano</span>()),
			<span style="color:#a6e22e">Namespace</span>: <span style="color:#a6e22e">newEvent</span>.<span style="color:#a6e22e">Namespace</span>,
		},
		<span style="color:#a6e22e">Count</span>:          <span style="color:#ae81ff">1</span>,
		<span style="color:#a6e22e">FirstTimestamp</span>: <span style="color:#a6e22e">now</span>,
		<span style="color:#a6e22e">InvolvedObject</span>: <span style="color:#a6e22e">newEvent</span>.<span style="color:#a6e22e">InvolvedObject</span>,
		<span style="color:#a6e22e">LastTimestamp</span>:  <span style="color:#a6e22e">now</span>,
		<span style="color:#a6e22e">Message</span>:        <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">messageFunc</span>(<span style="color:#a6e22e">newEvent</span>),
		<span style="color:#a6e22e">Type</span>:           <span style="color:#a6e22e">newEvent</span>.<span style="color:#a6e22e">Type</span>,
		<span style="color:#a6e22e">Reason</span>:         <span style="color:#a6e22e">newEvent</span>.<span style="color:#a6e22e">Reason</span>,
		<span style="color:#a6e22e">Source</span>:         <span style="color:#a6e22e">newEvent</span>.<span style="color:#a6e22e">Source</span>,
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">eventCopy</span>, <span style="color:#a6e22e">aggregateKey</span>
}

<span style="color:#75715e">// getEventKey builds unique event key based on source, involvedObject, reason, message
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getEventKey</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) <span style="color:#66d9ef">string</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>([]<span style="color:#66d9ef">string</span>{
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Source</span>.<span style="color:#a6e22e">Component</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Source</span>.<span style="color:#a6e22e">Host</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Kind</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Namespace</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Name</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">FieldPath</span>,
		string(<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">UID</span>),
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">APIVersion</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Type</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Reason</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Message</span>,
	},
		<span style="color:#e6db74">&#34;&#34;</span>)
}</code></pre></div>
<p>继续来看 EventCorrelate 方法，执行完 EventAggregate 并获取到聚合后（可能被更改）的事件和 cache key 之后，调用<code>c.logger.eventObserve(aggregateEvent, ckey)</code>进行事件记录，更新缓存。<br />
同样梳理下 eventObserve 的流程。<br />
1. 首先，通过 EventAggregate 返回的cache key 调用<code>e.lastEventObservationFromCache(key)</code>查询 cache，注意这个 cache 和 EventAggregate 中的 cache 并不是同一个，EventAggregate 中的 cache 是<code>EventAggregator.cache</code>即 EventAggregator 结构体中定义，而 eventObserve 的是<code>EventCorrelator.logger.cache</code>，是在 EventCorrelator 中定义。存的值也不是同一类型，这里保存的是 eventLog。<br />
2. 如果缓存不为空，那么要对事件 count 加一，并进行 merge 生成 patch。<br />
3. 最后将事件的 eventLog 加入缓存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// eventObserve records an event, or updates an existing one if key is a cache hit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">eventLogger</span>)<span style="color:#a6e22e">eventObserve</span>(<span style="color:#a6e22e">newEvent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>, []<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">var</span> (
		<span style="color:#a6e22e">patch</span> []<span style="color:#66d9ef">byte</span>
		<span style="color:#a6e22e">err</span>   <span style="color:#66d9ef">error</span>
	)
	<span style="color:#a6e22e">eventCopy</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">newEvent</span>
	<span style="color:#a6e22e">event</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">eventCopy</span>

	<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Unlock</span>()

	<span style="color:#75715e">// Check if there is an existing event we should update
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lastObservation</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">lastEventObservationFromCache</span>(<span style="color:#a6e22e">key</span>)

	<span style="color:#75715e">// If we found a result, prepare a patch
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">lastObservation</span>.<span style="color:#a6e22e">count</span> &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#75715e">// update the event based on the last observation so patch will work as desired
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Name</span> = <span style="color:#a6e22e">lastObservation</span>.<span style="color:#a6e22e">name</span>
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">ResourceVersion</span> = <span style="color:#a6e22e">lastObservation</span>.<span style="color:#a6e22e">resourceVersion</span>
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">FirstTimestamp</span> = <span style="color:#a6e22e">lastObservation</span>.<span style="color:#a6e22e">firstTimestamp</span>
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Count</span> = int32(<span style="color:#a6e22e">lastObservation</span>.<span style="color:#a6e22e">count</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

		<span style="color:#a6e22e">eventCopy2</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">event</span>
		<span style="color:#a6e22e">eventCopy2</span>.<span style="color:#a6e22e">Count</span> = <span style="color:#ae81ff">0</span>
		<span style="color:#a6e22e">eventCopy2</span>.<span style="color:#a6e22e">LastTimestamp</span> = <span style="color:#a6e22e">metav1</span>.<span style="color:#a6e22e">NewTime</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Unix</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>))
		<span style="color:#a6e22e">eventCopy2</span>.<span style="color:#a6e22e">Message</span> = <span style="color:#e6db74">&#34;&#34;</span>

		<span style="color:#a6e22e">newData</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">event</span>)
		<span style="color:#a6e22e">oldData</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">eventCopy2</span>)
		<span style="color:#a6e22e">patch</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">strategicpatch</span>.<span style="color:#a6e22e">CreateTwoWayMergePatch</span>(<span style="color:#a6e22e">oldData</span>, <span style="color:#a6e22e">newData</span>, <span style="color:#a6e22e">event</span>)
	}

	<span style="color:#75715e">// record our new observation
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">Add</span>(
		<span style="color:#a6e22e">key</span>,
		<span style="color:#a6e22e">eventLog</span>{
			<span style="color:#a6e22e">count</span>:           uint(<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Count</span>),
			<span style="color:#a6e22e">firstTimestamp</span>:  <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">FirstTimestamp</span>,
			<span style="color:#a6e22e">name</span>:            <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Name</span>,
			<span style="color:#a6e22e">resourceVersion</span>: <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">ResourceVersion</span>,
		},
	)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">patch</span>, <span style="color:#a6e22e">err</span>
}</code></pre></div>
<p>比较一下 EventAggregate 和 eventObserve 方法，大致流程都是会根据 Event 来搜索缓存，根据缓存是否存在来决定操作。但是在这里面，两类缓存的作用是不同的，EventAggregate 中的缓存，是为了对事件进行聚合，将相同 reason 的事件进行关联。而 eventObserve 是为了事件最终的存储，为将要存储的 event 保存 FirstTimestamp 和进行计数，并据此生成 patch bytes，最后由 EventSink 进行 Patch 操作。</p>

<h4 id="spamfilter">SpamFilter</h4>

<p>最后，在 EventCorrelate 中，还会调用一下 filterFunc，即过滤方法，判断是不是要跳过这个事件，不进行记录。具体调用的方法是 <code>EventSourceObjectSpamFilter.Filter</code>。Filter 同样维护了一个缓存，生成 key 的方法是 getSpamKey，它只基于<code>event.Source</code>和<code>event.InvolvedObject</code>来构建，缓存中存储的值为 spamRecord，它包含一个<code>flowcontrol.RateLimiter</code>对象，顾名思义，这是一个流量限制器，用途就是限流，具体实现在<code>client-go/util/flowcontrol/throttle.go</code>，这里不多做分析，有兴趣的同学可以自己看一下。<br />
简单解释一下，kubernetes 中实现的<code>flowcontrol.RateLimiter</code>基于 token bucket(即令牌桶)算法来完成限流。该算法原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。这里 NewTokenBucketRateLimiterWithClock 时，桶中的令牌的最大数量是<code>brust</code>，往桶中放入令牌的速率是<code>qps</code>，初始化时会向桶中放入<code>brust</code>个令牌。<code>TryAccept()</code>会尝试去桶中获取令牌，能过获取到则返回 true，反之返回 false。<br />
在 Filter 方法中，如果调用<code>record.rateLimiter.TryAccept()</code>返回了 false，说明此时 ratelimiter 不能立即获取到令牌，那么就 skip 事件。<br />
NewTokenBucketRateLimiterWithClock 时相应的配置，也是在 NewEventCorrelator 时传入的参数(defaultSpamBurst、defaultSpamQPS)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// getSpamKey builds unique event key based on source, involvedObject
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getSpamKey</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) <span style="color:#66d9ef">string</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>([]<span style="color:#66d9ef">string</span>{
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Source</span>.<span style="color:#a6e22e">Component</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">Source</span>.<span style="color:#a6e22e">Host</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Kind</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Namespace</span>,
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">Name</span>,
		string(<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">UID</span>),
		<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">InvolvedObject</span>.<span style="color:#a6e22e">APIVersion</span>,
	},
		<span style="color:#e6db74">&#34;&#34;</span>)
}

<span style="color:#75715e">// NewEventSourceObjectSpamFilter allows burst events from a source about an object with the specified qps refill.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewEventSourceObjectSpamFilter</span>(<span style="color:#a6e22e">lruCacheSize</span>, <span style="color:#a6e22e">burst</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">qps</span> <span style="color:#66d9ef">float32</span>, <span style="color:#a6e22e">clock</span> <span style="color:#a6e22e">clock</span>.<span style="color:#a6e22e">Clock</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">EventSourceObjectSpamFilter</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">EventSourceObjectSpamFilter</span>{
		<span style="color:#a6e22e">cache</span>: <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">lruCacheSize</span>),
		<span style="color:#a6e22e">burst</span>: <span style="color:#a6e22e">burst</span>,
		<span style="color:#a6e22e">qps</span>:   <span style="color:#a6e22e">qps</span>,
		<span style="color:#a6e22e">clock</span>: <span style="color:#a6e22e">clock</span>,
	}
}

<span style="color:#75715e">// spamRecord holds data used to perform spam filtering decisions.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">spamRecord</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#75715e">// rateLimiter controls the rate of events about this object
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rateLimiter</span> <span style="color:#a6e22e">flowcontrol</span>.<span style="color:#a6e22e">RateLimiter</span>
}

<span style="color:#75715e">// Filter controls that a given source+object are not exceeding the allowed rate.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventSourceObjectSpamFilter</span>) <span style="color:#a6e22e">Filter</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">record</span> <span style="color:#a6e22e">spamRecord</span>

	<span style="color:#75715e">// controls our cached information about this event (source+object)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">eventKey</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getSpamKey</span>(<span style="color:#a6e22e">event</span>)

	<span style="color:#75715e">// do we have a record of similar events in our cache?
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">found</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">eventKey</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">found</span> {
		<span style="color:#a6e22e">record</span> = <span style="color:#a6e22e">value</span>.(<span style="color:#a6e22e">spamRecord</span>)
	}

	<span style="color:#75715e">// verify we have a rate limiter for this record
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">rateLimiter</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">rateLimiter</span> = <span style="color:#a6e22e">flowcontrol</span>.<span style="color:#a6e22e">NewTokenBucketRateLimiterWithClock</span>(<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">qps</span>, <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">burst</span>, <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">clock</span>)
	}

	<span style="color:#75715e">// ensure we have available rate
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">filter</span> <span style="color:#f92672">:=</span> !<span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">rateLimiter</span>.<span style="color:#a6e22e">TryAccept</span>()

	<span style="color:#75715e">// update the cache
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">eventKey</span>, <span style="color:#a6e22e">record</span>)

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">filter</span>
}</code></pre></div>
<p>最终，经过这一系列处理，EventCorrelate 最终返回了 EventCorrelateResult 给调用者，并有调用者根据结果进行事件的最终记录，另外有一点需要注意，在最终更新/新建完事件后，调用者还要调用<code>eventCorrelator.UpdateState(newEvent)</code>来更新缓存的状态，这里更新的缓存是<code>EventCorrelator.logger.cache</code>，即 eventObserve 方法中记录的缓存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#75715e">// EventCorrelateResult is the result of a Correlate
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">EventCorrelateResult</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#75715e">// the event after correlation
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>
	<span style="color:#75715e">// if provided, perform a strategic patch when updating the record on the server
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Patch</span> []<span style="color:#66d9ef">byte</span>
	<span style="color:#75715e">// if true, do no further processing of the event
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Skip</span> <span style="color:#66d9ef">bool</span>
}

<span style="color:#75715e">// UpdateState based on the latest observed state from server
</span><span style="color:#75715e">// 主要更新的事件的 name/resourceversion
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">EventCorrelator</span>) <span style="color:#a6e22e">UpdateState</span>(<span style="color:#a6e22e">event</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Event</span>) {
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">logger</span>.<span style="color:#a6e22e">updateState</span>(<span style="color:#a6e22e">event</span>)
}</code></pre></div>
<h3 id="summary">summary</h3>

<p>本文通过从 kubelet 的 &lsquo;BirthCry&rsquo; 入手，分析了一个事件在 kubernetes 中的全部流程，以及如何对事件进行关联、聚合和过滤，同时其他组件的事件发送流程，也是大同小异，感兴趣的话可以自己选一个进行分析。另外，自己开发自定义的 controller 或其他自定义组件的时候，也可以尝试通过这一流程，将自己需要记录的事件，通过 kubernetes Event 的形式发送。<br />
附：kubernetes 事件整体流程<br />
<img src="/media/posts/cloud/kubernetes-events/kubernetes-event.jpg" alt="" /></p></article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="/tags/kubernetes"><span class="tag">Kubernetes</span></a></li>
        
          <li><a href="/tags/source-code"><span class="tag">Source Code</span></a></li>
        
          <li><a href="/tags/event"><span class="tag">Event</span></a></li>
        
          <li><a href="/tags/kubernetes-event"><span class="tag">Kubernetes Event</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        © This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.This post was published <strong>397</strong> days ago, content in the post may be inaccurate, even wrong now, please take risk yourself.
      </p>
    </footer>
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "maoqide-1" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
    
  </section>
  
<footer class="site-footer">
  <p>© 2017-2021 Maoqide</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank" rel="noopener">Nuo</a>.</p>
  
    <p><a href="http://www.miitbeian.gov.cn" title="Check ICP info" target="_blank" rel="noopener">浙ICP备19006182号</a></p>
  
</footer>


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js"></script>



<script async src="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video.min.js"></script>




<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    },
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>



<script src="/scripts/index.min.js"></script>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('\/service-worker.js').then(function() {
      console.log('[ServiceWorker] Registered');
    });
  }
</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-141682683-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c3c6dd2eb79bc741d95463b6040ac868";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>



  </body>
</html>
